<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Heiku</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="选择热爱">
<meta property="og:type" content="website">
<meta property="og:title" content="Heiku">
<meta property="og:url" content="http://home.sise.com/index.html">
<meta property="og:site_name" content="Heiku">
<meta property="og:description" content="选择热爱">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Heiku">
<meta name="twitter:description" content="选择热爱">
  
    <link rel="alternative" href="/atom.xml" title="Heiku" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css">
  

</head>
<body>
  <div id="container">
    <div id="wrap">
      <div class="outer">
        <section id="main">
  
    <article id="post-ConcurrentHashMap-源码分析" class="article article-type-post" itemscope itemprop="blogPost">
  
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/07/22/ConcurrentHashMap-源码分析/">ConcurrentHashMap-源码分析</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2018/07/22/ConcurrentHashMap-源码分析/" class="article-date">
  <time datetime="2018-07-22T15:29:04.000Z" itemprop="datePublished">2018-07-22</time>
</a>
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>产生原因</strong></p>
<ul>
<li>在多线程环境下，HashMap在扩容时会产生死循环，而线程安全的HashTable，在涉及多线程的操作都采用Synchronized锁住整个数组表，即所有线程在争夺一个资源，效率很低。</li>
</ul>
<p><strong>1.7 vs 1.8</strong></p>
<ul>
<li>1.7的 ConcurrentHashMap 采用的是分段锁的设计，底层数据结构是Segment + HashEntry，Segment实现了ReentrantLock，自带锁的功能，每次只锁定对应的Segment，多个线程争夺同个segment时，通过tryLock争夺，锁定的粒度下降了，性能也就提高了不少。</li>
</ul>
<ul>
<li>1.8的ConcurrentHashMap 摒弃了分段锁的概念（Segment），沿用了HashMap的思想，基于数组 + 链表 + 红黑树，底层采用的Node + CAS + Synchronized，保证并发的安全性，锁住的是粒度更小的Node。</li>
</ul>
<p><strong>分析</strong></p>
<p>内部类Node, 实现了Map.Entry，用于存储&lt;K,V&gt;键值对，节点用 volatile修饰，保证了多线程间的可见性，同时注意 value也用volatile修饰，无法通过setValue设置value变量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;</span><br><span class="line">    final int hash;</span><br><span class="line">    final K key;</span><br><span class="line">    volatile V val;</span><br><span class="line">    volatile Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">    Node(int hash, K key, V val, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        this.hash = hash;</span><br><span class="line">        this.key = key;</span><br><span class="line">        this.val = val;</span><br><span class="line">        this.next = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public final K getKey()       &#123; return key; &#125;</span><br><span class="line">    public final V getValue()     &#123; return val; &#125;</span><br><span class="line">    public final int hashCode()   &#123; return key.hashCode() ^ val.hashCode(); &#125;</span><br><span class="line">    public final String toString()&#123; return key + &quot;=&quot; + val; &#125;</span><br><span class="line">    public final V setValue(V value) &#123;</span><br><span class="line">        throw new UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public final boolean equals(Object o) &#123;</span><br><span class="line">        Object k, v, u; Map.Entry&lt;?,?&gt; e;</span><br><span class="line">        return ((o instanceof Map.Entry) &amp;&amp;</span><br><span class="line">                (k = (e = (Map.Entry&lt;?,?&gt;)o).getKey()) != null &amp;&amp;</span><br><span class="line">                (v = e.getValue()) != null &amp;&amp;</span><br><span class="line">                (k == key || k.equals(key)) &amp;&amp;</span><br><span class="line">                (v == (u = val) || v.equals(u)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Virtualized support for map.get(); overridden in subclasses.</span><br><span class="line">     */</span><br><span class="line">    Node&lt;K,V&gt; find(int h, Object k) &#123;</span><br><span class="line">        Node&lt;K,V&gt; e = this;</span><br><span class="line">        if (k != null) &#123;</span><br><span class="line">            do &#123;</span><br><span class="line">                K ek;</span><br><span class="line">                if (e.hash == h &amp;&amp;</span><br><span class="line">                    ((ek = e.key) == k || (ek != null &amp;&amp; k.equals(ek))))</span><br><span class="line">                    return e;</span><br><span class="line">            &#125; while ((e = e.next) != null);</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
        
          <p class="article-more-link">
            <a href="/2018/07/22/ConcurrentHashMap-源码分析/#more">More...</a>
          </p>
        
      

      
        
    </div>
  </div>
  
</article>



  
    <article id="post-使用位运算替代-运算符" class="article article-type-post" itemscope itemprop="blogPost">
  
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/05/21/使用位运算替代-运算符/">使用位运算替代+-运算符</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2018/05/21/使用位运算替代-运算符/" class="article-date">
  <time datetime="2018-05-21T07:56:13.000Z" itemprop="datePublished">2018-05-21</time>
</a>
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="最近在刷-LeetCode-时，看到一道关于位运算的算法题"><a href="#最近在刷-LeetCode-时，看到一道关于位运算的算法题" class="headerlink" title="最近在刷 LeetCode 时，看到一道关于位运算的算法题"></a>最近在刷 LeetCode 时，看到一道关于位运算的算法题</h4><p><a href="https://leetcode-cn.com/problems/sum-of-two-integers" target="_blank" rel="noopener">不使用运算符 + 和-，计算两整数a 、b之和</a> 归根到底，就是运用计算机底层原理，通过位运算进行运算。</p>
<p><strong>加法</strong><br>思路：用异运算构造两个数的和（不包含进位），用与运算再左移构造两者和的进位数，通过递归直到不进位。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public int getSum(int a, int b) &#123;</span><br><span class="line">        if (b == 0)&#123;</span><br><span class="line">            return a;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int sum = a ^ b;</span><br><span class="line">        int carry = (a &amp; b) &lt;&lt; 1;</span><br><span class="line"></span><br><span class="line">        return getSum(sum, carry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
        
          <p class="article-more-link">
            <a href="/2018/05/21/使用位运算替代-运算符/#more">More...</a>
          </p>
        
      

      
        
    </div>
  </div>
  
</article>



  
    <article id="post-HashMap-源码分析" class="article article-type-post" itemscope itemprop="blogPost">
  
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/21/HashMap-源码分析/">HashMap 源码分析</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2018/04/21/HashMap-源码分析/" class="article-date">
  <time datetime="2018-04-21T12:51:58.000Z" itemprop="datePublished">2018-04-21</time>
</a>
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>特征</strong></p>
<ul>
<li>根据键的 <strong>hascode</strong> 值存储数据，可直接定位值，具有很快的数据访问数组</li>
<li>遍历的顺序不确定</li>
<li>最多允许一条 null 键，允许多条记录的键为 null</li>
<li>非线程安全<br>  可使用 Collections.synchronizedMap 使 HashMap 具有线程安全的能力 或 ConcurrentHashMap</li>
</ul>
<p><strong>底层结构</strong></p>
<p>底层结构采用了数组，而数组的每一个元素都是多个 Node 构成的链表，当数组超过 threshold 时，数组将会扩容。</p>
<p>数组中的每一个都相当于一个单向链表，key 通过 hash() 后，相同的键值对会加入到链表中，当桶中的数过多时（链表长度 &gt; 8），将会转化为 红黑树，相比与Jdk 1.7， Jdk 1.8 中当链表过长时，链表转化为红黑树，在维护红黑树时，最坏情况下查找的时间复杂度为 O(log n)，比起单链表的 O(1) ~ O(n), 时间复杂度降低了，但所需要维护的空间占用却更多。</p>
        
          <p class="article-more-link">
            <a href="/2018/04/21/HashMap-源码分析/#more">More...</a>
          </p>
        
      

      
        
    </div>
  </div>
  
</article>



  
    <article id="post-ArrayList-源码分析" class="article article-type-post" itemscope itemprop="blogPost">
  
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/15/ArrayList-源码分析/">ArrayList 源码分析</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2018/04/15/ArrayList-源码分析/" class="article-date">
  <time datetime="2018-04-15T02:43:19.000Z" itemprop="datePublished">2018-04-15</time>
</a>
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>ArrayList 是平时常用的数据存储结构，它基于动态数组，支持随机访问，值得一提的是：<strong>它是不安全的</strong>。造成这种不安全的原因主要是：在在多线程环境下，向 ArrayList 添加或移除时，会产生数组越界等问题。推荐使用 Vector、CopyOnWriteArrayList 代替。</p>
<h3 id="ArrayList-与-Array-区别："><a href="#ArrayList-与-Array-区别：" class="headerlink" title="ArrayList 与 Array 区别："></a>ArrayList 与 Array 区别：</h3><ul>
<li>Array 包含的是基本类型和对象类型，而ArrayList 只能包含对象类型</li>
<li>Array 的大小的是固定的，所以在定义数组的时候尽量确定需要的数组大小，而ArrayList 的大小是动态变化的，当容量不足时能自动扩容</li>
<li>ArrayList 可以看作Array的增强版，提供了更多的方法和特性，在查找等操作上更方便</li>
</ul>
<hr>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;</span><br><span class="line">        implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable</span><br></pre></td></tr></table></figure>
        
          <p class="article-more-link">
            <a href="/2018/04/15/ArrayList-源码分析/#more">More...</a>
          </p>
        
      

      
        
    </div>
  </div>
  
</article>



  
    <article id="post-new-blog" class="article article-type-post" itemscope itemprop="blogPost">
  
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/10/new-blog/">新博客 启动</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2018/03/10/new-blog/" class="article-date">
  <time datetime="2018-03-10T01:58:26.000Z" itemprop="datePublished">2018-03-10</time>
</a>
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>花了一上午时间，通过参照  <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>  的文档和各种 <a href="https://github.com/limedroid/HexoLearning" target="_blank" rel="noopener">网上资料</a> ，终于将博客搭建起来， 由于没仔细参照文档，耽误了好多时间。期间接触到了 Markdown 这种写作语法，写起来还是挺轻便的。以后的新博客都写在这里，旧的博客不再更新。</p>

      

      
        
    </div>
  </div>
  
</article>



  
  
</section>
        <aside id="sidebar">
  <nav class="menus">
  	<ul>
  		<li><a href="/"><i class="icon icon-home"></i></a></li>
  		
			<li><a href="/archives"><i class="icon icon-fenlei"></i></a></li>
  		
  		
			<li><a href="/tags"><i class="icon icon-tag"></i></a></li>
  		
  		
  			<li><a href="https://github.com/Heiku" target="_blank"><i class="icon icon-github"></i></a></li>
  		
  	</ul>
  </nav>
  <a id="go-top" href="#"><i class="icon icon-up"></i></a>
</aside>

      </div>
      <footer id="footer">
  
	<div id="footer-info" class="inner">
	  &copy; 2018 John Doe 
	  - Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
	  - Theme <a href="https://github.com/hejianxian/hexo-theme-jane/" target="_blank">Jane</a>
	</div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
    <a href="/tags" class="mobile-nav-link">Tag</a>
  
    <a href="https://github.com/Heiku" class="mobile-nav-link">Github</a>
  
</nav>
    

<script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>