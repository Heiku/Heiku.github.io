<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Heiku</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://heiku.github.io/"/>
  <updated>2019-11-13T10:21:03.331Z</updated>
  <id>https://heiku.github.io/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Random</title>
    <link href="https://heiku.github.io/2019/11/12/Random/"/>
    <id>https://heiku.github.io/2019/11/12/Random/</id>
    <published>2019-11-12T12:51:37.000Z</published>
    <updated>2019-11-13T10:21:03.331Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Ramdon"><a href="#Ramdon" class="headerlink" title="Ramdon"></a>Ramdon</h2><h3 id="伪随机数"><a href="#伪随机数" class="headerlink" title="伪随机数"></a>伪随机数</h3><p>在大部分的程序语言中，随机数的生成都是伪随机的。什么是伪随机呢？伪随机性（Pseudorandomness）是指一个过程看起来是随机的，但实际上不是。它通常是使用一个确定性的算法计算出来的似乎是随机的数字，我们只要确定算法计算过程中的初始值，那么计算得到的随机数将会是固定的。</p><p>如果要获得真正的随机数，那么仅仅依靠软件去生成随机数是不够的，还需要一些随机的事件得到对应的参数指标，例如在 Linux 中获取随机数的方式就是依靠 intel CPU 电路中的热噪声信号产生的随机数，或者是用户的键盘输入的位置速度，大气中的噪声等方式获取真正的随机数，但都是依赖于专业的设备硬件。<br><br></p><h3 id="伪随机算法"><a href="#伪随机算法" class="headerlink" title="伪随机算法"></a>伪随机算法</h3><ul><li>线性同余方法（Linear Congruential Generator）LCG</li><li>梅森旋转算法（Mersenne twister） MT</li><li>M-sequence（Maximum length sequence） MLS</li></ul><h3 id="LCG"><a href="#LCG" class="headerlink" title="LCG"></a>LCG</h3><p><img src="/images/random/linear-congruential-form.jpg" alt></p><p>随机数的生成采用了递归公式，这里的 $ X_n $ 表示第 n 个数，$ X_n+1 $ 表示由上一个随机数得到的当前数值，变量 a, c, m 都是常数，LCG 的周期最大为 m，但大部分情况下都会小于 m，要令 LCG 达到最大周期，需要满足以下条件：</p><ol><li>c，m 互为质数</li><li>m 的所有质因数都能被整除 a - 1</li><li>如果 m 是4的倍数，那么 a - 1 也是</li><li>a, c, n都比 m 小</li></ol><p>优点：生成随机数的速度快，消耗内存小，但得知 seed 的情况下，容易根据随机的区间推断出来<br><br></p><h3 id="MT"><a href="#MT" class="headerlink" title="MT"></a>MT</h3><p>梅森旋转算法是基于二进制字段上的矩阵线性递归 $F_2$，对于一个 k 位的长度，MT 会在[0, $2^k$ - 1] 的区间之间生成离散型均匀分布的随机数，由于周期很长（$2^10037$ - 1）,使得随机数得区间更大，通过对 seed 生成得梅森旋转链进行旋转，处理得到旋转结果，使随机数在区间内均等分布。</p><p>因为其优秀得生成随机数速度及内存消耗空间得优化，在多个程序语言中已经使用，如 Python，PHP，Puby等。<br><br><br><a id="more"></a></p><h3 id="Java-Random"><a href="#Java-Random" class="headerlink" title="Java Random()"></a>Java Random()</h3><p>Java Random() 采用得随机数生成算法是 LCS，使用了48位得种子，根据使用者得需要将最终的随机数进行移位操作，得到使用者想要的随机数。<br>为什么是48为的种子呢？因为 LCS 的性质导致了生成的随机数的低位并不符合随机的特点，所以需要输出更多的位状态，例如当我们需要32位的时候，就需要生成比32位更多的位，来进行移位筛选。而不选择64的原因是48位已经够用了，64位将消耗额外的内存空间。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Random implements java.io.Serializable &#123;</span><br><span class="line">    // 随机数seed</span><br><span class="line">    private final AtomicLong seed;</span><br><span class="line"></span><br><span class="line">    // LCS 中的乘数 a</span><br><span class="line">    private static final long multiplier = 0x5DEECE66DL;</span><br><span class="line"></span><br><span class="line">    // LCS 中的加数 c</span><br><span class="line">    private static final long addend = 0xBL;</span><br><span class="line"></span><br><span class="line">    // LCS 中的模数 m</span><br><span class="line">    private static final long mask = (1L &lt;&lt; 48) - 1;</span><br><span class="line"></span><br><span class="line">    // 用于计算 nextDouble 中 double 的计算单位</span><br><span class="line">    private static final double DOUBLE_UNIT = 0x1.0p-53; // 1.0 / (1L &lt;&lt; 53)</span><br><span class="line"></span><br><span class="line">    // 当使用者未指定 seed使，使用 seedUniquifier 作为初始值计算 seed</span><br><span class="line">    private static final AtomicLong seedUniquifier = new AtomicLong(8682522807148012L);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h4 id="Construct"><a href="#Construct" class="headerlink" title="Construct"></a>Construct</h4><p>构造方法主要是判断使用者是否指定 seed 的情况下，生成填充成 48位的seed，为后续的生成随机数 next() 进行种子seed 初始化操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">// 如果玩家没有指定 seed，那么将通过 seedUniquifier 生成一个初始的long数值</span><br><span class="line">public Random() &#123;</span><br><span class="line">    // 通过 seedUniquifier() 的到一个long值，与当前时间进行异或运算</span><br><span class="line">    this(seedUniquifier() ^ System.nanoTime());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 默认 seedUniquifier 进行累乘计算，依赖的是系统的 CAS 操作</span><br><span class="line">// 当多线程的时候，这里可能会出现耗时等待，性能损失，所以在多线程的情况下，推荐 ThreadLocalRandom</span><br><span class="line">private static long seedUniquifier() &#123;</span><br><span class="line">    // L&apos;Ecuyer, &quot;Tables of Linear Congruential Generators of</span><br><span class="line">    // Different Sizes and Good Lattice Structure&quot;, 1999</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        long current = seedUniquifier.get();</span><br><span class="line">        long next = current * 181783497276652981L;</span><br><span class="line">        if (seedUniquifier.compareAndSet(current, next))</span><br><span class="line">            return next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 如果有指定seed，那么将seed 进行初始化，转化成48位的seed值</span><br><span class="line">public Random(long seed) &#123;</span><br><span class="line">    if (getClass() == Random.class)</span><br><span class="line">        this.seed = new AtomicLong(initialScramble(seed));</span><br><span class="line">    else &#123;</span><br><span class="line">        // subclass might have overriden setSeed</span><br><span class="line">        this.seed = new AtomicLong();</span><br><span class="line">        setSeed(seed);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 将初始的 seed 进行初始化，转化成指定位数</span><br><span class="line">private static long initialScramble(long seed) &#123;</span><br><span class="line">    return (seed ^ multiplier) &amp; mask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h4 id="next"><a href="#next" class="headerlink" title="next()"></a>next()</h4><p>next() 是生成随机数的具体方法，从下面的过程中，可以看出是采用递归的方式调用 LCS, 最后生成的 48位随机数会根据取值区间 bound进行移位操作，使数值在对应区间内</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 具体的随机数生成过程，可对应 LCS 公式进行回顾</span><br><span class="line">// 也是采用了 CAS 循环递归计算的过程</span><br><span class="line">protected int next(int bits) &#123;</span><br><span class="line">    long oldseed, nextseed;</span><br><span class="line">    AtomicLong seed = this.seed;</span><br><span class="line">    do &#123;</span><br><span class="line">        oldseed = seed.get();</span><br><span class="line">        nextseed = (oldseed * multiplier + addend) &amp; mask;</span><br><span class="line">    &#125; while (!seed.compareAndSet(oldseed, nextseed));</span><br><span class="line"></span><br><span class="line">    // 最终的结果微 48位的随机数，根据取值区间进行移位取值</span><br><span class="line">    return (int)(nextseed &gt;&gt;&gt; (48 - bits));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="nextInt"><a href="#nextInt" class="headerlink" title="nextInt()"></a>nextInt()</h4><p>因为 int 的字节长度位32位，所以在生成的随机数(48位)需要进行移位操作到32位空间，但移位的同时要注意的一个点，当使用者指定取值区间 bound的时候，因为 next() 生成随机数的区间较大，当取值区间变小后，移位的过程中，会分为多个取值空间，导致不同空间的随机数概率不同。</p><ul><li><p>当 n 是2的整数次幂时，n 肯定会被 $2^31$ 整除，这时候可以直接映射，只需运算一次 next(31);</p></li><li><p>当 n 不是2的整数次幂，那么就会出现刚才那样分配不均匀的情况，通过  <code>u - (r = u % bound) + m &lt; 0</code> 判断是否分布均匀，<br><code>u - (r = u % bound)</code> 表示临界点的值，由于 <code>m = bound - 1</code>，如果这时临界值 + m &lt; 1，那么说明发生了溢出，那么就可以通过判断是否溢出来判断生成的随机数是否在最后一个区间，如果是的话再进行一次 next(31) 重试</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public int nextInt() &#123;</span><br><span class="line">    return next(32);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public int nextInt(int bound) &#123;</span><br><span class="line">    if (bound &lt;= 0)</span><br><span class="line">        throw new IllegalArgumentException(BadBound);</span><br><span class="line"></span><br><span class="line">    // 获取31位的随机数</span><br><span class="line">    int r = next(31);</span><br><span class="line">    int m = bound - 1;</span><br><span class="line"></span><br><span class="line">    // 判断取值区间 bound，是不是为2的整数次幂</span><br><span class="line">    if ((bound &amp; m) == 0)  // i.e., bound is a power of 2</span><br><span class="line">        r = (int)((bound * (long)r) &gt;&gt; 31);</span><br><span class="line">    else &#123;</span><br><span class="line">        for (int u = r; u - (r = u % bound) + m &lt; 0; u = next(31));</span><br><span class="line">    &#125;</span><br><span class="line">  return r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="golang-random"><a href="#golang-random" class="headerlink" title="golang random"></a>golang random</h3><p>golang 中的随机数有两种一种是依靠变种的洗牌算法 <code>math/rand</code>，另一种是依靠操作系统的随机算法实现的真随机数 <code>crypto/rand</code></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Ramdon&quot;&gt;&lt;a href=&quot;#Ramdon&quot; class=&quot;headerlink&quot; title=&quot;Ramdon&quot;&gt;&lt;/a&gt;Ramdon&lt;/h2&gt;&lt;h3 id=&quot;伪随机数&quot;&gt;&lt;a href=&quot;#伪随机数&quot; class=&quot;headerlink&quot; title=&quot;伪随机数&quot;&gt;&lt;/a&gt;伪随机数&lt;/h3&gt;&lt;p&gt;在大部分的程序语言中，随机数的生成都是伪随机的。什么是伪随机呢？伪随机性（Pseudorandomness）是指一个过程看起来是随机的，但实际上不是。它通常是使用一个确定性的算法计算出来的似乎是随机的数字，我们只要确定算法计算过程中的初始值，那么计算得到的随机数将会是固定的。&lt;/p&gt;
&lt;p&gt;如果要获得真正的随机数，那么仅仅依靠软件去生成随机数是不够的，还需要一些随机的事件得到对应的参数指标，例如在 Linux 中获取随机数的方式就是依靠 intel CPU 电路中的热噪声信号产生的随机数，或者是用户的键盘输入的位置速度，大气中的噪声等方式获取真正的随机数，但都是依赖于专业的设备硬件。&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h3 id=&quot;伪随机算法&quot;&gt;&lt;a href=&quot;#伪随机算法&quot; class=&quot;headerlink&quot; title=&quot;伪随机算法&quot;&gt;&lt;/a&gt;伪随机算法&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;线性同余方法（Linear Congruential Generator）LCG&lt;/li&gt;
&lt;li&gt;梅森旋转算法（Mersenne twister） MT&lt;/li&gt;
&lt;li&gt;M-sequence（Maximum length sequence） MLS&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;LCG&quot;&gt;&lt;a href=&quot;#LCG&quot; class=&quot;headerlink&quot; title=&quot;LCG&quot;&gt;&lt;/a&gt;LCG&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;/images/random/linear-congruential-form.jpg&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;随机数的生成采用了递归公式，这里的 $ X_n $ 表示第 n 个数，$ X_n+1 $ 表示由上一个随机数得到的当前数值，变量 a, c, m 都是常数，LCG 的周期最大为 m，但大部分情况下都会小于 m，要令 LCG 达到最大周期，需要满足以下条件：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;c，m 互为质数&lt;/li&gt;
&lt;li&gt;m 的所有质因数都能被整除 a - 1&lt;/li&gt;
&lt;li&gt;如果 m 是4的倍数，那么 a - 1 也是&lt;/li&gt;
&lt;li&gt;a, c, n都比 m 小&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;优点：生成随机数的速度快，消耗内存小，但得知 seed 的情况下，容易根据随机的区间推断出来&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h3 id=&quot;MT&quot;&gt;&lt;a href=&quot;#MT&quot; class=&quot;headerlink&quot; title=&quot;MT&quot;&gt;&lt;/a&gt;MT&lt;/h3&gt;&lt;p&gt;梅森旋转算法是基于二进制字段上的矩阵线性递归 $F_2$，对于一个 k 位的长度，MT 会在[0, $2^k$ - 1] 的区间之间生成离散型均匀分布的随机数，由于周期很长（$2^10037$ - 1）,使得随机数得区间更大，通过对 seed 生成得梅森旋转链进行旋转，处理得到旋转结果，使随机数在区间内均等分布。&lt;/p&gt;
&lt;p&gt;因为其优秀得生成随机数速度及内存消耗空间得优化，在多个程序语言中已经使用，如 Python，PHP，Puby等。&lt;br&gt;&lt;br&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://heiku.github.io/tags/Java/"/>
    
      <category term="Ramdom" scheme="https://heiku.github.io/tags/Ramdom/"/>
    
      <category term="JDK" scheme="https://heiku.github.io/tags/JDK/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot启动分析-BeanDefinition</title>
    <link href="https://heiku.github.io/2019/11/01/SpringBoot%E5%90%AF%E5%8A%A8%E5%88%86%E6%9E%90-BeanDefinition/"/>
    <id>https://heiku.github.io/2019/11/01/SpringBoot启动分析-BeanDefinition/</id>
    <published>2019-11-01T10:35:17.000Z</published>
    <updated>2019-11-01T12:09:03.776Z</updated>
    
    <content type="html"><![CDATA[<h2 id="BeanDefinition"><a href="#BeanDefinition" class="headerlink" title="BeanDefinition"></a>BeanDefinition</h2><p>BeanDefinition 是一个描述 Bean 信息的接口，它描述和定义了一个创建 bean 的所有基本信息，其中就包括了以下属性</p><ol><li>parentName：     双亲 bean 的名称</li><li>beanClassName：  bean 的类名，但一定有，因为如果该 bean 是由工厂bean 产生的，那么这里的 beanClassName 为空</li><li>scope：          作用域，如 singleton, prototype</li><li>lazyInit:        是否为懒加载，如果被设置为 lazy = true，那么这个 bean 会在使用的时候才会被实例化</li><li>factoryBeanName：生产这个 bean 的工厂名</li><li>propertyValues： 属性值</li><li>role：           bean 的角色类型，包括了 APPLICATION, SUPPORT, INFRASTRUCTURE<br>…<br><br></li></ol><p><img src="/images/springboot/RootBeanDefinition.png" alt><br><br></p><h3 id="AbstractDefinition"><a href="#AbstractDefinition" class="headerlink" title="AbstractDefinition"></a>AbstractDefinition</h3><p>AbstractDefinition 实现了 BeanDefinition 接口，为子类 RootBeanDefiniton, ChildBeanDefinition, GenericBeanDefinition 提供了 BeanDefinition 公用逻辑的封装，主要封装有以下：</p><ol><li>定义了公共的构造函数</li><li>为属性值定义了 getter/ setter 等方法，方便获取设置属性值</li><li>提供了 overrideFrom() 用于覆盖 当前bean 的定义 及 applyDefaults() 用于设置 bean 的默认属性值</li></ol><p><br><br>值得一提的是，AbstractBeanDefinition 同时实现了 BeanMetadataAttributeAccessor，即为 BeanDefinition 扩展了以下功能 source, attreibute 等功能：</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">// AttributeAccessorSupport 可以为 bean 修改对应的 attrbute</span><br><span class="line">// BeanMetadataElement      可以为 bean 设置对应的 source</span><br><span class="line">public class BeanMetadataAttributeAccessor extends AttributeAccessorSupport implements BeanMetadataElement &#123;</span><br><span class="line"></span><br><span class="line">    // 设置 configuration source</span><br><span class="line">    public void setSource(@Nullable Object source) &#123;</span><br><span class="line">            this.source = source;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    @Nullable</span><br><span class="line">    public Object getSource() &#123;</span><br><span class="line">        return this.source;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Nullable</span><br><span class="line">public BeanMetadataAttribute getMetadataAttribute(String name) &#123;</span><br><span class="line">return (BeanMetadataAttribute) super.getAttribute(name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void setAttribute(String name, @Nullable Object value) &#123;</span><br><span class="line">super.setAttribute(name, new BeanMetadataAttribute(name, value));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">@Nullable</span><br><span class="line">public Object getAttribute(String name) &#123;</span><br><span class="line">BeanMetadataAttribute attribute = (BeanMetadataAttribute) super.getAttribute(name);</span><br><span class="line">return (attribute != null ? attribute.getValue() : null);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">@Nullable</span><br><span class="line">public Object removeAttribute(String name) &#123;</span><br><span class="line">BeanMetadataAttribute attribute = (BeanMetadataAttribute) super.removeAttribute(name);</span><br><span class="line">return (attribute != null ? attribute.getValue() : null);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h3 id="RootBeanDefinition-amp-ChildBeanDefinition"><a href="#RootBeanDefinition-amp-ChildBeanDefinition" class="headerlink" title="RootBeanDefinition &amp; ChildBeanDefinition"></a>RootBeanDefinition &amp; ChildBeanDefinition</h3><p>RootBeanDefinition 不能设置 parent bean，而 ChildBeanDefinition 必须设置 parent bean,设置的方式通常由构造函数实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class ChildBeanDefinition extends AbstractBeanDefinition &#123;</span><br><span class="line"></span><br><span class="line">@Nullable</span><br><span class="line">private String parentName;</span><br><span class="line"></span><br><span class="line">public ChildBeanDefinition(String parentName) &#123;</span><br><span class="line">super();</span><br><span class="line">this.parentName = parentName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public ChildBeanDefinition(String parentName, MutablePropertyValues pvs) &#123;</span><br><span class="line">super(null, pvs);</span><br><span class="line">this.parentName = parentName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public ChildBeanDefinition(</span><br><span class="line">String parentName, ConstructorArgumentValues cargs, MutablePropertyValues pvs) &#123;</span><br><span class="line"></span><br><span class="line">super(cargs, pvs);</span><br><span class="line">this.parentName = parentName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>RootBeanDefinition 在 Spring 容器的创建过程中或者是运行期间被频繁使用，是因为它代表了一种特定的 merged bean definition，即能够表示出它由多个原始的 bean 彼此继承之间的关系。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">// AbstractBeanFactory.class</span><br><span class="line">// 合并的过程是，通过递归不断合并 parent &amp; child，通过构造函数中的属性重新赋值，得到新的 BeanDefinition,最终返回 RootBeanDefinition</span><br><span class="line">protected RootBeanDefinition getMergedBeanDefinition(String beanName, BeanDefinition bd, @Nullable BeanDefinition containingBd)</span><br><span class="line">    throws BeanDefinitionStoreException &#123;</span><br><span class="line"></span><br><span class="line">    //  获取 map mergedBeanDefinitions 的对象锁</span><br><span class="line">    synchronized (this.mergedBeanDefinitions) &#123;</span><br><span class="line"></span><br><span class="line">        // 定义一个 RootBeanDefinition 引用</span><br><span class="line">        RootBeanDefinition mbd = null;</span><br><span class="line"></span><br><span class="line">        // Check with full lock now in order to enforce the same merged instance.</span><br><span class="line">        // 尝试找出相同的实例名，并准备合并</span><br><span class="line">        if (containingBd == null) &#123;</span><br><span class="line">            mbd = this.mergedBeanDefinitions.get(beanName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 并没有找到相同的实例</span><br><span class="line">        if (mbd == null) &#123;</span><br><span class="line"></span><br><span class="line">            // parentName == null，说明当前已经是 RootBeanDefinition，那么就直接使用，clone(this)并重新赋值</span><br><span class="line">            if (bd.getParentName() == null) &#123;</span><br><span class="line">                // Use copy of given root bean definition.</span><br><span class="line">                if (bd instanceof RootBeanDefinition) &#123;</span><br><span class="line">                    mbd = ((RootBeanDefinition) bd).cloneBeanDefinition();</span><br><span class="line">                &#125;</span><br><span class="line">                else &#123;</span><br><span class="line">                    mbd = new RootBeanDefinition(bd);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                // Child bean definition: needs to be merged with parent.</span><br><span class="line">                // 如果存在 parentName, 那么说明当前 BeanDefinition 为 ChildBeanDefinition</span><br><span class="line">                // 那么就继续调用 getMergedBeanDefinition()，递归获取 RootBeanDefinition,并不断的合并创建对象并属性拷贝</span><br><span class="line">                BeanDefinition pbd;</span><br><span class="line">                try &#123;</span><br><span class="line"></span><br><span class="line">                    // 这里的 transFormedBeanName 是为了获取 bean 的真正名称</span><br><span class="line">                    // 因为如果是 factoryBean 创建出来的对象，那么它的名称中将带有 &amp;，而目的就是为了 remove it</span><br><span class="line">                    String parentBeanName = transformedBeanName(bd.getParentName());</span><br><span class="line">                    if (!beanName.equals(parentBeanName)) &#123;</span><br><span class="line">                        pbd = getMergedBeanDefinition(parentBeanName);</span><br><span class="line">                    &#125;</span><br><span class="line">                    else &#123;</span><br><span class="line">                        BeanFactory parent = getParentBeanFactory();</span><br><span class="line">                        if (parent instanceof ConfigurableBeanFactory) &#123;</span><br><span class="line">                            pbd = ((ConfigurableBeanFactory) parent).getMergedBeanDefinition(parentBeanName);</span><br><span class="line">                        &#125;</span><br><span class="line">                        else &#123;</span><br><span class="line">                            throw new NoSuchBeanDefinitionException(parentBeanName,</span><br><span class="line">                                    &quot;Parent name &apos;&quot; + parentBeanName + &quot;&apos; is equal to bean name &apos;&quot; + beanName +</span><br><span class="line">                                    &quot;&apos;: cannot be resolved without an AbstractBeanFactory parent&quot;);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                catch (NoSuchBeanDefinitionException ex) &#123;</span><br><span class="line">                    throw new BeanDefinitionStoreException(bd.getResourceDescription(), beanName,</span><br><span class="line">                            &quot;Could not resolve parent bean definition &apos;&quot; + bd.getParentName() + &quot;&apos;&quot;, ex);</span><br><span class="line">                &#125;</span><br><span class="line">                // Deep copy with overridden values.</span><br><span class="line">                // 重新实例化一个 RootBeanDefinition 并进行属性赋值</span><br><span class="line">                mbd = new RootBeanDefinition(pbd);</span><br><span class="line">                // 覆盖旧属性</span><br><span class="line">                mbd.overrideFrom(bd);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // Set default singleton scope, if not configured before.</span><br><span class="line">            // 如果之前没有配置作用域，那么就设置默认的 singleton scope</span><br><span class="line">            if (!StringUtils.hasLength(mbd.getScope())) &#123;</span><br><span class="line">                mbd.setScope(RootBeanDefinition.SCOPE_SINGLETON);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // A bean contained in a non-singleton bean cannot be a singleton itself.</span><br><span class="line">            // Let&apos;s correct this on the fly here, since this might be the result of</span><br><span class="line">            // parent-child merging for the outer bean, in which case the original inner bean</span><br><span class="line">            // definition will not have inherited the merged outer bean&apos;s singleton status.</span><br><span class="line">            if (containingBd != null &amp;&amp; !containingBd.isSingleton() &amp;&amp; mbd.isSingleton()) &#123;</span><br><span class="line">                mbd.setScope(containingBd.getScope());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // Cache the merged bean definition for the time being</span><br><span class="line">            // (it might still get re-merged later on in order to pick up metadata changes)</span><br><span class="line">            if (containingBd == null &amp;&amp; isCacheBeanMetadata()) &#123;</span><br><span class="line">                this.mergedBeanDefinitions.put(beanName, mbd);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return mbd;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h3 id="Merged-amp-Save"><a href="#Merged-amp-Save" class="headerlink" title="Merged &amp; Save"></a>Merged &amp; Save</h3><p>可以看到，每次 RootBeanDefinition merge ChildBeanDefinition 的大致流程如下：</p><ol><li>new RootBeanDefinition(child)</li><li>merge process</li><li>overrideFrom(child)<br><br></li></ol><p>那么，在合并的过程中，除了一些基本的属性赋值，有哪些属性被合并到 rootBeanDefinition 中呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">// 在每次合并的时候，都会实例化 new RootBeanDefinition(this)</span><br><span class="line">// 而在 RootBeanDefiniition 的构造函数中，会调用 super(this)，那么就是调用 AbstractBeanDefiniiton constructor</span><br><span class="line">// AbstractBeanDefinition.class</span><br><span class="line">protected AbstractBeanDefinition(BeanDefinition original) &#123;</span><br><span class="line">    </span><br><span class="line">    // 这里会调用 AttributeAccessorSupport.copyAttributesForm()</span><br><span class="line">    copyAttributesFrom(original);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// AttributeAccessorSupport.class</span><br><span class="line">// 这里会将 BeanDefinition 中的 attributes 进行遍历加入到当前 parentBeanDefinition 的 attribute 中</span><br><span class="line">protected void copyAttributesFrom(AttributeAccessor source) &#123;</span><br><span class="line">    Assert.notNull(source, &quot;Source must not be null&quot;);</span><br><span class="line">    String[] attributeNames = source.attributeNames();</span><br><span class="line">    for (String attributeName : attributeNames) &#123;</span><br><span class="line">        setAttribute(attributeName, source.getAttribute(attributeName));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// AbstractBeanDefinition.class</span><br><span class="line">// 同理, 在 overrideFrom()，会将 child 的 constructorArgValue，propertyValue，methodOverrides 中的属性保留到当前 bd的属性中</span><br><span class="line">public void overrideFrom(BeanDefinition other) &#123;</span><br><span class="line">    if (other instanceof AbstractBeanDefinition) &#123;</span><br><span class="line">        AbstractBeanDefinition otherAbd = (AbstractBeanDefinition) other;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (otherAbd.hasConstructorArgumentValues()) &#123;</span><br><span class="line">        getConstructorArgumentValues().addArgumentValues(other.getConstructorArgumentValues());</span><br><span class="line">    &#125;</span><br><span class="line">    if (otherAbd.hasPropertyValues()) &#123;</span><br><span class="line">        getPropertyValues().addPropertyValues(other.getPropertyValues());</span><br><span class="line">    &#125;</span><br><span class="line">    if (otherAbd.hasMethodOverrides()) &#123;</span><br><span class="line">        getMethodOverrides().addOverrides(otherAbd.getMethodOverrides());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在构建 bean 的过程中，会频繁使用到 BeanDefinition , BeanDefinition 作为通用接口，它规定了 Bean 的一些基本定义，为了更好的使用 BeanDefinition，AbstractBeanDefinition 对其进行了封装，加入了构造过程及 getter/setter 便于子类的使用调用，具体的实现分别为 RootBeanDefinition 和 ChildBeanDefinition ，它们用来表示 BeanDefinition 之间的一种继承关系，当我们在实例化 Bean 的时候，通常只需使用到 RootBeanDefinition ，但由于多个 BeanDefinition 之间的属性依赖关系，所以就需要对这些 AbstractBeanDefinition 进行合并，这个过程就就会进行属性的赋值和属性的记录。<br><br></p><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><ul><li><a href="https://blog.csdn.net/andy_zhang2007/article/details/85421417" target="_blank" rel="noopener">BeanDefinition</a>  </li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;BeanDefinition&quot;&gt;&lt;a href=&quot;#BeanDefinition&quot; class=&quot;headerlink&quot; title=&quot;BeanDefinition&quot;&gt;&lt;/a&gt;BeanDefinition&lt;/h2&gt;&lt;p&gt;BeanDefinition 是一个描述 Bean 信息的接口，它描述和定义了一个创建 bean 的所有基本信息，其中就包括了以下属性&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;parentName：     双亲 bean 的名称&lt;/li&gt;
&lt;li&gt;beanClassName：  bean 的类名，但一定有，因为如果该 bean 是由工厂bean 产生的，那么这里的 beanClassName 为空&lt;/li&gt;
&lt;li&gt;scope：          作用域，如 singleton, prototype&lt;/li&gt;
&lt;li&gt;lazyInit:        是否为懒加载，如果被设置为 lazy = true，那么这个 bean 会在使用的时候才会被实例化&lt;/li&gt;
&lt;li&gt;factoryBeanName：生产这个 bean 的工厂名&lt;/li&gt;
&lt;li&gt;propertyValues： 属性值&lt;/li&gt;
&lt;li&gt;role：           bean 的角色类型，包括了 APPLICATION, SUPPORT, INFRASTRUCTURE&lt;br&gt;…&lt;br&gt;&lt;br&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;/images/springboot/RootBeanDefinition.png&quot; alt&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h3 id=&quot;AbstractDefinition&quot;&gt;&lt;a href=&quot;#AbstractDefinition&quot; class=&quot;headerlink&quot; title=&quot;AbstractDefinition&quot;&gt;&lt;/a&gt;AbstractDefinition&lt;/h3&gt;&lt;p&gt;AbstractDefinition 实现了 BeanDefinition 接口，为子类 RootBeanDefiniton, ChildBeanDefinition, GenericBeanDefinition 提供了 BeanDefinition 公用逻辑的封装，主要封装有以下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;定义了公共的构造函数&lt;/li&gt;
&lt;li&gt;为属性值定义了 getter/ setter 等方法，方便获取设置属性值&lt;/li&gt;
&lt;li&gt;提供了 overrideFrom() 用于覆盖 当前bean 的定义 及 applyDefaults() 用于设置 bean 的默认属性值&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;值得一提的是，AbstractBeanDefinition 同时实现了 BeanMetadataAttributeAccessor，即为 BeanDefinition 扩展了以下功能 source, attreibute 等功能：&lt;/p&gt;
    
    </summary>
    
    
      <category term="Spring" scheme="https://heiku.github.io/tags/Spring/"/>
    
      <category term="SpringBoot" scheme="https://heiku.github.io/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot 启动分析-refresh()</title>
    <link href="https://heiku.github.io/2019/10/30/SpringBoot-%E5%90%AF%E5%8A%A8%E5%88%86%E6%9E%90-refresh/"/>
    <id>https://heiku.github.io/2019/10/30/SpringBoot-启动分析-refresh/</id>
    <published>2019-10-30T06:44:20.000Z</published>
    <updated>2019-10-30T10:45:13.796Z</updated>
    
    <content type="html"><![CDATA[<h2 id="refresh"><a href="#refresh" class="headerlink" title="refresh()"></a>refresh()</h2><p><br></p><p>上一篇分析 <code>SpringBoot</code> 启动过程中的 构造过程及 <code>run()</code>，在构造的过程中，主要是根据应用程序的类型设置 <code>WebApplicationType</code>，同时根据 <code>spring.factories</code>的配置读取初始化容器的一些监听器 <code>listeners</code> 和初始化器 <code>initializers</code>。  </p><p>而在 <code>run()</code>中，主要是对应用上下文 <code>ApplicationContext</code> 创建并进行初始化，设置 <code>WebApplicationType</code>对应的 <code>environment</code>，然后 <code>refreshContext(context)</code> ，最后加载 <code>listeners start(),running</code> 并加入 <code>SpringRunners</code>.  </p><p>在 <code>refreshContext(context)</code> 主要有下面几个工作：</p><ol><li><a href="#prepareRefresh">prepareRefresh()</a></li><li><a href="#prepareBeanFactory">prepareBeanFactory()</a></li><li><a href="#postProcessBeanFactory">postProcessBeanFactory()</a></li><li><a href="#invokeBeanFactoryPostProcessors">invokeBeanFactoryPostProcessors()</a></li><li><a href="#registerBeanPostProcessors">registerBeanPostProcessors()</a></li><li><a href="#initMessageSource">initMessageSource()</a></li><li><a href="#initApplicationEventMulticaster">initApplicationEventMulticaster()</a></li><li><a href="#onRefresh">onRefresh()</a></li><li><a href="#registerListeners">registerListeners()</a></li><li><a href="#finishBeanFactoryInitialization">finishBeanFactoryInitialization()</a></li><li><a href="#finishRefresh">finishRefresh()</a><br><br></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">  public void refresh() throws BeansException, IllegalStateException &#123;</span><br><span class="line">// 获取监视器锁</span><br><span class="line">      synchronized(this.startupShutdownMonitor) &#123;</span><br><span class="line">      </span><br><span class="line">      // 刷新上下文前的准备，记录状态，验证必要属性</span><br><span class="line">          this.prepareRefresh();</span><br><span class="line">          ConfigurableListableBeanFactory beanFactory = this.obtainFreshBeanFactory();</span><br><span class="line">          </span><br><span class="line">          // 配置标准的 beanFactory，设置 classloader, bean表达解析器，同时注册重要的bean组件</span><br><span class="line">          this.prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">          try &#123;</span><br><span class="line">          // 模板方法，交由子类对 beanFactory 进行后置处理</span><br><span class="line">              this.postProcessBeanFactory(beanFactory);</span><br><span class="line">              </span><br><span class="line">              // 调用 beanFactoryPostPorcessor </span><br><span class="line">              this.invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line">              </span><br><span class="line">              // 注册容器中的 beanPostProcessors</span><br><span class="line">              this.registerBeanPostProcessors(beanFactory);</span><br><span class="line">              </span><br><span class="line">              // 初始化国际工具类 MessageSource</span><br><span class="line">              this.initMessageSource();</span><br><span class="line">              </span><br><span class="line">              // 初始化并注册事件广播器 ApplicationEventMulticaster</span><br><span class="line">              this.initApplicationEventMulticaster();</span><br><span class="line">              </span><br><span class="line">              // 模板方法，根据应用的具体类型交由子类具体处理，如果是web类型，通常是构建webServer</span><br><span class="line">              this.onRefresh();</span><br><span class="line">              </span><br><span class="line">              // 注册容器中的监听器，包括spring.factories 和 自定义 bean listenr</span><br><span class="line">              this.registerListeners();</span><br><span class="line">              </span><br><span class="line">              // 实例化所有的单例 bean （非 Lazy）,beanPostProcessor 开始起作用</span><br><span class="line">              this.finishBeanFactoryInitialization(beanFactory);</span><br><span class="line">              </span><br><span class="line">              // refresh() 后的额外工作，包括清除resource cahce，注册 LifeCycleProcessor及发布上下文已经刷新的事件 ContexntRefreshedEvent</span><br><span class="line">              this.finishRefresh();</span><br><span class="line">          &#125; catch (BeansException var9) &#123;</span><br><span class="line"></span><br><span class="line">// 如果刷新上下文的过程中，出现异常，那么销毁所有已经创建的 bean</span><br><span class="line">              this.destroyBeans();</span><br><span class="line">              </span><br><span class="line">              // 重置 context 的刷新状态，即将 active = false</span><br><span class="line">              this.cancelRefresh(var9);</span><br><span class="line">              throw var9;</span><br><span class="line">          &#125; finally &#123;</span><br><span class="line">          // 无论失败与否，已经不再需要 bean metadata，重置 Spring 的内核缓存</span><br><span class="line">              this.resetCommonCaches();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p> <br></p><h3 id="prepareRefresh"><a href="#prepareRefresh" class="headerlink" title="prepareRefresh()"></a>prepareRefresh()</h3><p>prepareRefresh()  是为 refresh() 进行了准备工作，主要准备工作有：</p><ol><li><p>记录 Spring 容器的启动时间，同时设置 active , closed 的状态</p></li><li><p>初始化属性源信息 (propertySources)，及验证当前环境中的必要的属性是否存在</p></li><li><p>设置 earlyApplicationListeners &amp; earlyApplicationEvents 属性列表</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">  protected void prepareRefresh() &#123;</span><br><span class="line">  // 记录启动时间</span><br><span class="line">      this.startupDate = System.currentTimeMillis();</span><br><span class="line">      </span><br><span class="line">      // 设置关闭状态，及开启状态</span><br><span class="line">      this.closed.set(false);</span><br><span class="line">      this.active.set(true);</span><br><span class="line"></span><br><span class="line">   // 初始化属性源信息</span><br><span class="line">      this.initPropertySources();</span><br><span class="line">      </span><br><span class="line">      // 验证当前环境中的必要属性是否存在</span><br><span class="line">      this.getEnvironment().validateRequiredProperties();</span><br><span class="line">      </span><br><span class="line">      // 判断 earlyApplicationListeners 是否存在，是的话加入到应用程序监听器 ApplicationListeners中，</span><br><span class="line">      // 否则的话创建新的对象</span><br><span class="line">      if (this.earlyApplicationListeners == null) &#123;</span><br><span class="line">          this.earlyApplicationListeners = new LinkedHashSet(this.applicationListeners);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">          this.applicationListeners.clear();</span><br><span class="line">          this.applicationListeners.addAll(this.earlyApplicationListeners);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">// 创建 earlyApplicationEvents </span><br><span class="line">      this.earlyApplicationEvents = new LinkedHashSet();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><br></p><h3 id="prepareBeanFactory"><a href="#prepareBeanFactory" class="headerlink" title="prepareBeanFactory()"></a>prepareBeanFactory()</h3><p>prepareBeanFactory() 获取了容器中的 beanFactory 并进行以下操作：</p><ol><li>设置 bean 加载器 BeanClassLoader（用于 Bean 的加载），bean 表达式解析器 BeanExpressionResolver </li><li>添加注册属性编辑器 propertyEditorRegistrar，添加 BeanPostProcessor （ApplicationContextAwareProcessor）</li><li>将几个重要的 bean ( BeanFactory, ResourceLoader, ApplicationEventPublisher, ApplicationContext ) 加载到容器中，后续使用</li><li>添加 ApplicationListenerDetector 到 beanFactory 中的 beanPostProcessor 列表中</li><li>检查并注入其他的属性信息，如 loadTimeWeaver, environment 等</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">protected void prepareBeanFactory(ConfigurableListableBeanFactory beanFactory) &#123;</span><br><span class="line">// 设置 beanClassLoader</span><br><span class="line">        beanFactory.setBeanClassLoader(this.getClassLoader());</span><br><span class="line">        </span><br><span class="line">        // 设置 bean 表达解析器（用于处理定义 Bean 过程中的一些解析表达式： 例如 #&#123;sqlProperties&#125; ）</span><br><span class="line">        beanFactory.setBeanExpressionResolver(new StandardBeanExpressionResolver(beanFactory.getBeanClassLoader()));</span><br><span class="line">        </span><br><span class="line">        // 添加注册属性编辑器</span><br><span class="line">        beanFactory.addPropertyEditorRegistrar(new ResourceEditorRegistrar(this, this.getEnvironment()));</span><br><span class="line">        </span><br><span class="line">        // 添加 ApplicationContextAwareProcessor 到 beanPostProcessors 列表中</span><br><span class="line">        beanFactory.addBeanPostProcessor(new ApplicationContextAwareProcessor(this));</span><br><span class="line">        </span><br><span class="line">        /** 取消 EnvironmentAware, EmbeddedValueResolverAware, ResourceLoaderAware,</span><br><span class="line">        *AApplicationEventPublisherAware, MessageSourceAware, ApplicationContextAware </span><br><span class="line">        *这些接口的依赖注入，因为这些接口的属性设置工作已经被 ApplicationContextAwareProcessor代替</span><br><span class="line">        *</span><br><span class="line">        *这些接口将会保存在 beanFactory 中的 ignoredDependencyInterfaces 列表中</span><br><span class="line">        */ </span><br><span class="line">        beanFactory.ignoreDependencyInterface(EnvironmentAware.class);</span><br><span class="line">        beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware.class);</span><br><span class="line">        beanFactory.ignoreDependencyInterface(ResourceLoaderAware.class);</span><br><span class="line">        beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class);</span><br><span class="line">        beanFactory.ignoreDependencyInterface(MessageSourceAware.class);</span><br><span class="line">        beanFactory.ignoreDependencyInterface(ApplicationContextAware.class);</span><br><span class="line">        </span><br><span class="line">        // 添加重要的 bean 到容器中，BeanFactory, ResourceLoader,</span><br><span class="line">        ApplicationEventPublisher, ApplicationContext</span><br><span class="line">          这里可以设置为 this，是因为都实现了对应接口中的方法</span><br><span class="line">          </span><br><span class="line">          这些类属性将会被保存在 beanFactory 中的 resolvableDependencies map表中</span><br><span class="line">        beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory);</span><br><span class="line">        beanFactory.registerResolvableDependency(ResourceLoader.class, this);</span><br><span class="line">        beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, this);</span><br><span class="line">        beanFactory.registerResolvableDependency(ApplicationContext.class, this);</span><br><span class="line">        </span><br><span class="line">        // 添加 ApplicationListenerDetector 到 beanFactory 中的 beanPostProcessors 列表中</span><br><span class="line">        beanFactory.addBeanPostProcessor(new ApplicationListenerDetector(this));</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">// 检查代码织入,通常用于 Aspect切面的准备工作</span><br><span class="line">        if (beanFactory.containsBean(&quot;loadTimeWeaver&quot;)) &#123;</span><br><span class="line">            beanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory));</span><br><span class="line">            beanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 检查并设置 localBean，environment, systemProperties, systemEnvironment</span><br><span class="line">        if (!beanFactory.containsLocalBean(&quot;environment&quot;)) &#123;</span><br><span class="line">            beanFactory.registerSingleton(&quot;environment&quot;, this.getEnvironment());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (!beanFactory.containsLocalBean(&quot;systemProperties&quot;)) &#123;</span><br><span class="line">            beanFactory.registerSingleton(&quot;systemProperties&quot;, this.getEnvironment().getSystemProperties());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (!beanFactory.containsLocalBean(&quot;systemEnvironment&quot;)) &#123;</span><br><span class="line">            beanFactory.registerSingleton(&quot;systemEnvironment&quot;, this.getEnvironment().getSystemEnvironment());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    </span><br><span class="line">    // ApplicationContextAwareProcessor extend BeanPostProcessor</span><br><span class="line">    // 在 postProcessBeforeInitialization()的时候，调用 invokeAwareInterfaces</span><br><span class="line">    // 根据 bean 的类型设置对应接口的属性信息</span><br><span class="line">    private void invokeAwareInterfaces(Object bean) &#123;</span><br><span class="line">        if (bean instanceof Aware) &#123;</span><br><span class="line">            if (bean instanceof EnvironmentAware) &#123;</span><br><span class="line">                ((EnvironmentAware)bean).setEnvironment(this.applicationContext.getEnvironment());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (bean instanceof EmbeddedValueResolverAware) &#123;</span><br><span class="line">                ((EmbeddedValueResolverAware)bean).setEmbeddedValueResolver(this.embeddedValueResolver);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (bean instanceof ResourceLoaderAware) &#123;</span><br><span class="line">                ((ResourceLoaderAware)bean).setResourceLoader(this.applicationContext);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (bean instanceof ApplicationEventPublisherAware) &#123;</span><br><span class="line">                ((ApplicationEventPublisherAware)bean).setApplicationEventPublisher(this.applicationContext);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (bean instanceof MessageSourceAware) &#123;</span><br><span class="line">                ((MessageSourceAware)bean).setMessageSource(this.applicationContext);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (bean instanceof ApplicationContextAware) &#123;</span><br><span class="line">                ((ApplicationContextAware)bean).setApplicationContext(this.applicationContext);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><br></p><h3 id="postProcessBeanFactory"><a href="#postProcessBeanFactory" class="headerlink" title="postProcessBeanFactory()"></a>postProcessBeanFactory()</h3><p>postProcessBeanFactory() 主要是对设置属性后的 beanFactory 进行了后续的操作， 不同的应用程序类型会由不同的类进行操作，例如在 Servlet 类型中，对应的操作类为 AnnotationConfigServletWebServerApplicationContext， 而在 Reactive 中对应的则是 AnnotationConfigReactiveWebServerApplicationContext，区别在于调用的父类方法 postProcessBeanFactory()上，而读取注册 basePackages、annotatedClass 属性上的 bean 组件都是相同的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// AnnotationConfigReactiveWebServerApplicationContext.class </span><br><span class="line">protected void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) &#123;</span><br><span class="line">// 调用父类 AbstractApplicationContext的方法实现</span><br><span class="line">        super.postProcessBeanFactory(beanFactory);</span><br><span class="line">        </span><br><span class="line">        // 如果设置了 basePackages 属性，那么调用 ClassPathBeanDefinitionScanner 扫描 basePackages 下的bean组件，并注册到容器中</span><br><span class="line">        if (!ObjectUtils.isEmpty(this.basePackages)) &#123;</span><br><span class="line">            this.scanner.scan(this.basePackages);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">// 如果设置了 annotatedClasses 属性，那么调用 AnnotatedBeanDefinitionReader 注册这些带注解的bean信息</span><br><span class="line">        if (!this.annotatedClasses.isEmpty()) &#123;</span><br><span class="line">            this.reader.register(ClassUtils.toClassArray(this.annotatedClasses));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><br></p><h3 id="invokeBeanFactoryPostProcessors"><a href="#invokeBeanFactoryPostProcessors" class="headerlink" title="invokeBeanFactoryPostProcessors()"></a>invokeBeanFactoryPostProcessors()</h3><ol><li>BeanFactoryPostProcessors 可以对容器中加载 bean，进行属性修改，这里得bean 还未实例化，更没有初始，允许修改 bean 定义</li><li>BeanDefinitionRegistryPostProcessor 是对于 BeanFactoryPostProcessor 的扩展，允许修改 bean 注册器，也就是说可以在 BeanFactoryPostProcessor 之前对 bean 进行定义的修改</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line">public interface BeanFactoryPostProcessor &#123;</span><br><span class="line">    void postProcessBeanFactory(ConfigurableListableBeanFactory var1) throws BeansException;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public interface BeanDefinitionRegistryPostProcessor extends BeanFactoryPostProcessor &#123;</span><br><span class="line">    void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry var1) throws BeansException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>invokeBeanFactoryPostProcessors() 主要是调用获取当前容器中得 beanPostProessor ( BeanFactoryPostProcessor &amp; BeanDefinitionRegistryPostProcessor ) ，根据 postProcessor 的接口实现 PriorityOrdered &amp; Ordered 进行排序并调用，实现逻辑中 beanDefinitionRegistryPostProcessor 会在 beanFactoryPostProcessor 之前进行调用，保证了两种接口之间的调用顺序.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br></pre></td><td class="code"><pre><span class="line">// 具体的调用过程被委托到 PostProcessorRegistrationDelegate.class 下</span><br><span class="line">public static void invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory beanFactory, List&lt;BeanFactoryPostProcessor&gt; beanFactoryPostProcessors) &#123;</span><br><span class="line"></span><br><span class="line">// 创建集合 processedBeans 用于保存所有处理过的 postProcessor name</span><br><span class="line">       Set&lt;String&gt; processedBeans = new HashSet();</span><br><span class="line">       </span><br><span class="line">       // 定义两个列表分别存放 beanFactoryPostProcessor &amp; beanDefinitionRegistryPostProcessor</span><br><span class="line">       ArrayList regularPostProcessors;</span><br><span class="line">       ArrayList registryProcessors;</span><br><span class="line">       int var9;</span><br><span class="line">       ArrayList currentRegistryProcessors;</span><br><span class="line">       String[] postProcessorNames;</span><br><span class="line">       </span><br><span class="line">       // 如果 beanFactory 属于 beanDefinitionRegistry 的时候，遍历 beanFactoryPostProcessors，区分存储到 regulatPostProcessors &amp; registryProcessors</span><br><span class="line">       if (beanFactory instanceof BeanDefinitionRegistry) &#123;</span><br><span class="line">           BeanDefinitionRegistry registry = (BeanDefinitionRegistry)beanFactory;</span><br><span class="line">           regularPostProcessors = new ArrayList();</span><br><span class="line">           registryProcessors = new ArrayList();</span><br><span class="line">           Iterator var6 = beanFactoryPostProcessors.iterator();</span><br><span class="line"></span><br><span class="line">// registryPostPorcessors -&gt; BeanDefinitionRegistryPostProcessor</span><br><span class="line">// regulatPostProcessors -&gt; BeanFactoryPostProcessor</span><br><span class="line">           while(var6.hasNext()) &#123;</span><br><span class="line">               BeanFactoryPostProcessor postProcessor = (BeanFactoryPostProcessor)var6.next();</span><br><span class="line">               if (postProcessor instanceof BeanDefinitionRegistryPostProcessor) &#123;</span><br><span class="line">                   BeanDefinitionRegistryPostProcessor registryProcessor = (BeanDefinitionRegistryPostProcessor)postProcessor;</span><br><span class="line">                   registryProcessor.postProcessBeanDefinitionRegistry(registry);</span><br><span class="line">                   registryProcessors.add(registryProcessor);</span><br><span class="line">               &#125; else &#123;</span><br><span class="line">                   regularPostProcessors.add(postProcessor);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           </span><br><span class="line">           // 获取所有类型为 BeanDefinitionRegistryPostProcessor 的 bean name</span><br><span class="line">           currentRegistryProcessors = new ArrayList();</span><br><span class="line">           postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);</span><br><span class="line">           String[] var16 = postProcessorNames;</span><br><span class="line">           var9 = postProcessorNames.length;</span><br><span class="line"></span><br><span class="line">// 先筛选出实现 PriorityOrdered 接口的 beanDefinitionRegistryPostProcessor，</span><br><span class="line">   并保存在集合 currentRegistryProcessors, processedBeans 中</span><br><span class="line">           int var10;</span><br><span class="line">           String ppName;</span><br><span class="line">           for(var10 = 0; var10 &lt; var9; ++var10) &#123;</span><br><span class="line">               ppName = var16[var10];</span><br><span class="line">               if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123;</span><br><span class="line">                   currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));</span><br><span class="line">                   processedBeans.add(ppName);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">// 根据 priorityOrdered 的优先级进行排序</span><br><span class="line">           sortPostProcessors(currentRegistryProcessors, beanFactory);</span><br><span class="line">           registryProcessors.addAll(currentRegistryProcessors);</span><br><span class="line">           </span><br><span class="line">           // 遍历调用执行所有的 PriorityOrdered BeanDefinitionRegistryProcessors</span><br><span class="line">           invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);</span><br><span class="line">           currentRegistryProcessors.clear();</span><br><span class="line">           postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);</span><br><span class="line">           var16 = postProcessorNames;</span><br><span class="line">           var9 = postProcessorNames.length;</span><br><span class="line"></span><br><span class="line">// 重新获取并筛选出实现 Ordered 接口的 BeanDefinitionRegistryPostProcessors</span><br><span class="line">           for(var10 = 0; var10 &lt; var9; ++var10) &#123;</span><br><span class="line">               ppName = var16[var10];</span><br><span class="line">               if (!processedBeans.contains(ppName) &amp;&amp; beanFactory.isTypeMatch(ppName, Ordered.class)) &#123;</span><br><span class="line">                   currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));</span><br><span class="line">                   processedBeans.add(ppName);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">// 根据 Ordered 优先级排序，然后遍历调用</span><br><span class="line">           sortPostProcessors(currentRegistryProcessors, beanFactory);</span><br><span class="line">           registryProcessors.addAll(currentRegistryProcessors);</span><br><span class="line">           invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);</span><br><span class="line">           currentRegistryProcessors.clear();</span><br><span class="line">           boolean reiterate = true;</span><br><span class="line"></span><br><span class="line">// 找到其余的 BeanDefinitionRegistryPostProcessor, 进行排序并注册调用</span><br><span class="line">           while(reiterate) &#123;</span><br><span class="line">               reiterate = false;</span><br><span class="line">               postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);</span><br><span class="line">               String[] var19 = postProcessorNames;</span><br><span class="line">               var10 = postProcessorNames.length;</span><br><span class="line"></span><br><span class="line">               for(int var26 = 0; var26 &lt; var10; ++var26) &#123;</span><br><span class="line">                   String ppName = var19[var26];</span><br><span class="line">                   if (!processedBeans.contains(ppName)) &#123;</span><br><span class="line">                       currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));</span><br><span class="line">                       processedBeans.add(ppName);</span><br><span class="line">                       reiterate = true;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               sortPostProcessors(currentRegistryProcessors, beanFactory);</span><br><span class="line">               registryProcessors.addAll(currentRegistryProcessors);</span><br><span class="line">               invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);</span><br><span class="line">               currentRegistryProcessors.clear();</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">// 因为 BeanDefinitionRegistryPostProcessors 实现了 BeanFactoryPostProcessor 中的方法，</span><br><span class="line">  所以这里调用在接口中实现的 postProcessBeanFactory() </span><br><span class="line">           invokeBeanFactoryPostProcessors((Collection)registryProcessors, (ConfigurableListableBeanFactory)beanFactory);</span><br><span class="line">           invokeBeanFactoryPostProcessors((Collection)regularPostProcessors, (ConfigurableListableBeanFactory)beanFactory);</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">       </span><br><span class="line">       // 如果当前 beanFactroy 不是 beanDefinitionRegistry，则直接执行 BeanFactoryPostProcessor 接口</span><br><span class="line">           invokeBeanFactoryPostProcessors((Collection)beanFactoryPostProcessors, (ConfigurableListableBeanFactory)beanFactory);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 接着就是获取所有类型为 BeanFactoryPostProcessor 的 bean name</span><br><span class="line">       String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanFactoryPostProcessor.class, true, false);</span><br><span class="line">       </span><br><span class="line">       // 复用集合，用 regularPostProcessors 存储实现接口 PriorityOrdered 的 beanFactoryPostProcessor，</span><br><span class="line">       用 registeyProcessors 存储是新建接口 Ordered 的 beanFactoryPostProcessor</span><br><span class="line">       regularPostProcessors = new ArrayList();</span><br><span class="line">       registryProcessors = new ArrayList();</span><br><span class="line">       currentRegistryProcessors = new ArrayList();</span><br><span class="line">       postProcessorNames = postProcessorNames;</span><br><span class="line">       int var20 = postProcessorNames.length;</span><br><span class="line"></span><br><span class="line">// 遍历根据实现的接口进行分组</span><br><span class="line">       String ppName;</span><br><span class="line">       for(var9 = 0; var9 &lt; var20; ++var9) &#123;</span><br><span class="line">           ppName = postProcessorNames[var9];</span><br><span class="line">           if (!processedBeans.contains(ppName)) &#123;</span><br><span class="line">               if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123;</span><br><span class="line">                   regularPostProcessors.add(beanFactory.getBean(ppName, BeanFactoryPostProcessor.class));</span><br><span class="line">               &#125; else if (beanFactory.isTypeMatch(ppName, Ordered.class)) &#123;</span><br><span class="line">                   registryProcessors.add(ppName);</span><br><span class="line">               &#125; else &#123;</span><br><span class="line">                   currentRegistryProcessors.add(ppName);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">// 重排序实现接口 PriorityOrdered 的 beanFactoryPostProcessors，遍历并调用执行</span><br><span class="line">       sortPostProcessors(regularPostProcessors, beanFactory);</span><br><span class="line">       invokeBeanFactoryPostProcessors((Collection)regularPostProcessors, (ConfigurableListableBeanFactory)beanFactory);</span><br><span class="line">       List&lt;BeanFactoryPostProcessor&gt; orderedPostProcessors = new ArrayList();</span><br><span class="line">       Iterator var21 = registryProcessors.iterator();</span><br><span class="line"></span><br><span class="line">       while(var21.hasNext()) &#123;</span><br><span class="line">           String postProcessorName = (String)var21.next();</span><br><span class="line">           orderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">// 重排序实现接口 Ordered 的 beanFactoryPostProcessors，遍历并调用执行</span><br><span class="line">       sortPostProcessors(orderedPostProcessors, beanFactory);</span><br><span class="line">       invokeBeanFactoryPostProcessors((Collection)orderedPostProcessors, (ConfigurableListableBeanFactory)beanFactory);</span><br><span class="line">       List&lt;BeanFactoryPostProcessor&gt; nonOrderedPostProcessors = new ArrayList();</span><br><span class="line">       Iterator var24 = currentRegistryProcessors.iterator();</span><br><span class="line"></span><br><span class="line">       while(var24.hasNext()) &#123;</span><br><span class="line">           ppName = (String)var24.next();</span><br><span class="line">           nonOrderedPostProcessors.add(beanFactory.getBean(ppName, BeanFactoryPostProcessor.class));</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">// 遍历调用其余没有实现排序接口的 beanFactoryPostProcessor</span><br><span class="line">       invokeBeanFactoryPostProcessors((Collection)nonOrderedPostProcessors, (ConfigurableListableBeanFactory)beanFactory);</span><br><span class="line">       </span><br><span class="line">       // 清空缓存</span><br><span class="line">       beanFactory.clearMetadataCache();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><br></p><h3 id="registerBeanPostProcessors"><a href="#registerBeanPostProcessors" class="headerlink" title="registerBeanPostProcessors()"></a>registerBeanPostProcessors()</h3><p>registerBeanPostProcessors() 主要是找到容器中的 BeanPostProcessor 类型的 bean，根据具体的实现 PriorityOrdered，Ordered, 进行分类并排序，然后注册到 beanFactory 中的属性列表中，具体的实现被 AbstractApplicationContext 交由 PostProcessorRegistrationDelegate.registerBeanPostProcessors 实现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">// PostProcessorRegistrationDelegate.class</span><br><span class="line">public static void registerBeanPostProcessors(ConfigurableListableBeanFactory beanFactory, AbstractApplicationContext applicationContext) &#123;</span><br><span class="line"></span><br><span class="line">// 获取所有类型为 BeanPostProcessor 的 postProcessorNames</span><br><span class="line">        String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanPostProcessor.class, true, false);</span><br><span class="line">        // 统计总数</span><br><span class="line">        int beanProcessorTargetCount = beanFactory.getBeanPostProcessorCount() + 1 + postProcessorNames.length;</span><br><span class="line">        </span><br><span class="line">        // 在 beanFactory 中添加 PostProcessorRegistrationDelegate 委托类的子类 BeanPostProcessorChecker 检查类，用于在 beanPostProcessor 实例化期间，当 bean 被创建时打印信息</span><br><span class="line">        beanFactory.addBeanPostProcessor(new PostProcessorRegistrationDelegate.BeanPostProcessorChecker(beanFactory, beanProcessorTargetCount));</span><br><span class="line">        </span><br><span class="line">        // 构建列表 priorityOrderedPostProcessors, internalPostProcessors, </span><br><span class="line">        orderedPostProcessorNames, nonOrderedPostProcessorNames，用于存储不同类型的 postProcessor</span><br><span class="line">        List&lt;BeanPostProcessor&gt; priorityOrderedPostProcessors = new ArrayList();</span><br><span class="line">        List&lt;BeanPostProcessor&gt; internalPostProcessors = new ArrayList();</span><br><span class="line">        List&lt;String&gt; orderedPostProcessorNames = new ArrayList();</span><br><span class="line">        List&lt;String&gt; nonOrderedPostProcessorNames = new ArrayList();</span><br><span class="line">        String[] var8 = postProcessorNames;</span><br><span class="line">        int var9 = postProcessorNames.length;</span><br><span class="line"></span><br><span class="line">// 遍历 beanPostProcessor name array，根据 beanPostProcessor 的具体类型进行分类</span><br><span class="line">        String ppName;</span><br><span class="line">        BeanPostProcessor pp;</span><br><span class="line">        for(int var10 = 0; var10 &lt; var9; ++var10) &#123;</span><br><span class="line">            ppName = var8[var10];</span><br><span class="line">            if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123;</span><br><span class="line">                pp = (BeanPostProcessor)beanFactory.getBean(ppName, BeanPostProcessor.class);</span><br><span class="line">                priorityOrderedPostProcessors.add(pp);</span><br><span class="line">                if (pp instanceof MergedBeanDefinitionPostProcessor) &#123;</span><br><span class="line">                    internalPostProcessors.add(pp);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else if (beanFactory.isTypeMatch(ppName, Ordered.class)) &#123;</span><br><span class="line">                orderedPostProcessorNames.add(ppName);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                nonOrderedPostProcessorNames.add(ppName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">// 加载实现 PriorityOrdered 接口的 beanPostProcessors，根据优先级进行排序，然后对 priorityOrderedPostProcessors 进行遍历注册到 beanFactory</span><br><span class="line">        sortPostProcessors(priorityOrderedPostProcessors, beanFactory);</span><br><span class="line">        registerBeanPostProcessors(beanFactory, (List)priorityOrderedPostProcessors);</span><br><span class="line">        </span><br><span class="line">        // 加载实现 Ordered 接口的 beanPostProcessors，排序后遍历注册到 beanFactory 中</span><br><span class="line">        List&lt;BeanPostProcessor&gt; orderedPostProcessors = new ArrayList();</span><br><span class="line">        Iterator var14 = orderedPostProcessorNames.iterator();</span><br><span class="line"></span><br><span class="line">        while(var14.hasNext()) &#123;</span><br><span class="line">            String ppName = (String)var14.next();</span><br><span class="line">            BeanPostProcessor pp = (BeanPostProcessor)beanFactory.getBean(ppName, BeanPostProcessor.class);</span><br><span class="line">            orderedPostProcessors.add(pp);</span><br><span class="line">            if (pp instanceof MergedBeanDefinitionPostProcessor) &#123;</span><br><span class="line">                internalPostProcessors.add(pp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sortPostProcessors(orderedPostProcessors, beanFactory);</span><br><span class="line">        registerBeanPostProcessors(beanFactory, (List)orderedPostProcessors);</span><br><span class="line">        </span><br><span class="line">        // 加载剩余未实现 ordered 的 beanPostProcessors, 遍历并加载到 beanFactory 中</span><br><span class="line">        List&lt;BeanPostProcessor&gt; nonOrderedPostProcessors = new ArrayList();</span><br><span class="line">        Iterator var17 = nonOrderedPostProcessorNames.iterator();</span><br><span class="line"></span><br><span class="line">        while(var17.hasNext()) &#123;</span><br><span class="line">            ppName = (String)var17.next();</span><br><span class="line">            pp = (BeanPostProcessor)beanFactory.getBean(ppName, BeanPostProcessor.class);</span><br><span class="line">            nonOrderedPostProcessors.add(pp);</span><br><span class="line">            if (pp instanceof MergedBeanDefinitionPostProcessor) &#123;</span><br><span class="line">                internalPostProcessors.add(pp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        registerBeanPostProcessors(beanFactory, (List)nonOrderedPostProcessors);</span><br><span class="line">        sortPostProcessors(internalPostProcessors, beanFactory);</span><br><span class="line">        </span><br><span class="line">        // 遍历注册内部后置处理器 internalPostProcessors，</span><br><span class="line">        registerBeanPostProcessors(beanFactory, (List)internalPostProcessors);</span><br><span class="line">        </span><br><span class="line">        // 重新注册 用于检查内部bean 的 postProcessor （ApplicationListenerDetector），</span><br><span class="line">        // 将这个检查处理器重新移动到 processors chain 末尾</span><br><span class="line">        beanFactory.addBeanPostProcessor(new ApplicationListenerDetector(applicationContext));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><br></p><h3 id="initMessageSource"><a href="#initMessageSource" class="headerlink" title="initMessageSource()"></a>initMessageSource()</h3><p>MessageSource 是 Spring 支持国际化的一种方式，通过 MessageSource，可以读取根据 Locale 的具体位置设置，自动选择对应的 messages.properties (messages_en.properties, messages_ch_properties) 配置文件。然后根据业务需求 getMessage() 的到我们要的配置信息。  </p><p>而 initMessageSource() 的作用就在于读取 messageSource bean，并进行初始化</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">protected void initMessageSource() &#123;</span><br><span class="line">        ConfigurableListableBeanFactory beanFactory = this.getBeanFactory();</span><br><span class="line">        </span><br><span class="line">        // 判断本地是否存在 messageSource bean</span><br><span class="line">        if (beanFactory.containsLocalBean(&quot;messageSource&quot;)) &#123;</span><br><span class="line">            this.messageSource = (MessageSource)beanFactory.getBean(&quot;messageSource&quot;, MessageSource.class);</span><br><span class="line">            </span><br><span class="line">            // 如果属于 HierarchicalMessageSource (可用于处理分层 messageSource)，那么设置父属性</span><br><span class="line">            if (this.parent != null &amp;&amp; this.messageSource instanceof HierarchicalMessageSource) &#123;</span><br><span class="line">                HierarchicalMessageSource hms = (HierarchicalMessageSource)this.messageSource;</span><br><span class="line">                if (hms.getParentMessageSource() == null) &#123;</span><br><span class="line">                    hms.setParentMessageSource(this.getInternalParentMessageSource());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">        </span><br><span class="line">        // 否则创建一个新的对象</span><br><span class="line">            DelegatingMessageSource dms = new DelegatingMessageSource();</span><br><span class="line">            </span><br><span class="line">            // 然后属性设置</span><br><span class="line">            dms.setParentMessageSource(this.getInternalParentMessageSource());</span><br><span class="line">            this.messageSource = dms;</span><br><span class="line">            </span><br><span class="line">            // 最后，将 messageSource 作为一个单例的 bean 注册到 beanFactory 中</span><br><span class="line">            beanFactory.registerSingleton(&quot;messageSource&quot;, this.messageSource);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><br></p><h3 id="initApplicationEventMulticaster"><a href="#initApplicationEventMulticaster" class="headerlink" title="initApplicationEventMulticaster()"></a>initApplicationEventMulticaster()</h3><p>通常，我们在 Spring 中 发送一个事件 event 是采用 applicationContext.pushEvent() ，实际上，具体的事件发送广播是被交由 applicationEventMulticaster 发送，具体的过程将后续将会出一篇 Spring Event 事件机制进行介绍。而 initApplicationEventMulticaster() 就是将 applicationEventMulticater 注册到 beanFactory 容器中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// AbstractApplicationContext.class</span><br><span class="line">protected void initApplicationEventMulticaster() &#123;</span><br><span class="line"></span><br><span class="line">// 获取 beanFactory，判断本地是否存在 bean 组件 applicationEventMulticaster</span><br><span class="line">        ConfigurableListableBeanFactory beanFactory = this.getBeanFactory();</span><br><span class="line">        if (beanFactory.containsLocalBean(&quot;applicationEventMulticaster&quot;)) &#123;</span><br><span class="line">            this.applicationEventMulticaster = (ApplicationEventMulticaster)beanFactory.getBean(&quot;applicationEventMulticaster&quot;, ApplicationEventMulticaster.class);</span><br><span class="line">           ...</span><br><span class="line"></span><br><span class="line">        &#125; else &#123;</span><br><span class="line">        </span><br><span class="line">        // 如果本地不存在，则实例化一个 simpleApplicationEventMulticaster，并且单例注册到 beanfactory </span><br><span class="line">            this.applicationEventMulticaster = new SimpleApplicationEventMulticaster(beanFactory);</span><br><span class="line">            beanFactory.registerSingleton(&quot;applicationEventMulticaster&quot;, this.applicationEventMulticaster);</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><br></p><h3 id="onRefresh"><a href="#onRefresh" class="headerlink" title="onRefresh()"></a>onRefresh()</h3><p>onRefresh() 和上面的 postProcessBeanFactory() 一样，都是一个模板方法，具体的实现会根据 webApplicationType 的具体类型找到对应的 GenericWebApplicationContext || ReactiveWebServerApplicationContext 等，具体实现都有所不同。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// AbstractApplicationContext.class</span><br><span class="line">protected void onRefresh() throws BeansException &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// GenericWebApplicationContext.class</span><br><span class="line">// 具体过程是初始化主题</span><br><span class="line">protected void onRefresh() &#123;</span><br><span class="line">        this.themeSource = UiApplicationContextUtils.initThemeSource(this);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// ServletWebServerApplicationContext.class // ReactiveWebServerApplicationContext</span><br><span class="line">// 具体过程是构建一个 servlet webServer</span><br><span class="line">protected void onRefresh() &#123;</span><br><span class="line">        super.onRefresh();</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            this.createWebServer();</span><br><span class="line">        &#125; catch (Throwable var2) &#123;</span><br><span class="line">            throw new ApplicationContextException(&quot;Unable to start web server&quot;, var2);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h3 id="registerListeners"><a href="#registerListeners" class="headerlink" title="registerListeners()"></a>registerListeners()</h3><p>在上面的步骤中，我们已经将事件广播器 applicationEventMulticaster 注册到了容器中，有了广播器，那么接下来就是收集容器中的所有 listener bean 组件，将他们保存在集合中，以便事件发布时能够遍历监听器列表，通过适配 eventType，找到对应的 listener 并进行处理。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">// AbstractApplicationContext.class</span><br><span class="line">protected void registerListeners() &#123;</span><br><span class="line">// 获取监听器 listeners 集合，这里的 listeners 是各个模块中的 spirng.factories 中的 listeners</span><br><span class="line">        Iterator var1 = this.getApplicationListeners().iterator();</span><br><span class="line"></span><br><span class="line">// 遍历listeners ，加入到 AbstractApplicationEventListeners中的 applicationListeners 集合中</span><br><span class="line">        while(var1.hasNext()) &#123;</span><br><span class="line">            ApplicationListener&lt;?&gt; listener = (ApplicationListener)var1.next();</span><br><span class="line">            this.getApplicationEventMulticaster().addApplicationListener(listener);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">// 获取所有监听器的名称，并遍历加入到 AbstractApplicationEventListeners applicationListenerBeans // 这里的 listeners 指的是容器中实现了 ApplicationListener 的 bean 组件</span><br><span class="line">// 包括了我们自定义的 listener 或者是 spring中定义的 @Bean mvcResourceUrlProvider</span><br><span class="line">        String[] listenerBeanNames = this.getBeanNamesForType(ApplicationListener.class, true, false);</span><br><span class="line">        String[] var7 = listenerBeanNames;</span><br><span class="line">        int var3 = listenerBeanNames.length;</span><br><span class="line"></span><br><span class="line">        for(int var4 = 0; var4 &lt; var3; ++var4) &#123;</span><br><span class="line">            String listenerBeanName = var7[var4];</span><br><span class="line">            this.getApplicationEventMulticaster().addApplicationListenerBean(listenerBeanName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">// 如果存在早期事件，那么直接发布出去</span><br><span class="line">        Set&lt;ApplicationEvent&gt; earlyEventsToProcess = this.earlyApplicationEvents;</span><br><span class="line">        this.earlyApplicationEvents = null;</span><br><span class="line">        if (earlyEventsToProcess != null) &#123;</span><br><span class="line">            Iterator var9 = earlyEventsToProcess.iterator();</span><br><span class="line"></span><br><span class="line">            while(var9.hasNext()) &#123;</span><br><span class="line">                ApplicationEvent earlyEvent = (ApplicationEvent)var9.next();</span><br><span class="line">                this.getApplicationEventMulticaster().multicastEvent(earlyEvent);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><br></p><h3 id="finishBeanFactoryInitialization"><a href="#finishBeanFactoryInitialization" class="headerlink" title="finishBeanFactoryInitialization()"></a>finishBeanFactoryInitialization()</h3><p>finishBeanFactoryInitialization(beanFactory) 的主要作用是实例化所有的单例 bean ( 非 Lazy )，这个时候，容器中的 beanPostProcessor 将会开始起作用。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">protected void finishBeanFactoryInitialization(ConfigurableListableBeanFactory beanFactory) &#123;</span><br><span class="line">// 初始化 context 的转换服务, conversionService 是一个类型转换接口，可实现自定义类型间的转换</span><br><span class="line">        if (beanFactory.containsBean(&quot;conversionService&quot;) &amp;&amp; beanFactory.isTypeMatch(&quot;conversionService&quot;, ConversionService.class)) &#123;</span><br><span class="line">            beanFactory.setConversionService((ConversionService)beanFactory.getBean(&quot;conversionService&quot;, ConversionService.class));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">// 注册内置的值处理器，用于对 property 进行处理（例如占位符处理）</span><br><span class="line">        if (!beanFactory.hasEmbeddedValueResolver()) &#123;</span><br><span class="line">            beanFactory.addEmbeddedValueResolver((strVal) -&gt; &#123;</span><br><span class="line">                return this.getEnvironment().resolvePlaceholders(strVal);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">// 获取 LoadTimeWeaverAware Bean</span><br><span class="line">        String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware.class, false, false);</span><br><span class="line">        String[] var3 = weaverAwareNames;</span><br><span class="line">        int var4 = weaverAwareNames.length;</span><br><span class="line"></span><br><span class="line">        for(int var5 = 0; var5 &lt; var4; ++var5) &#123;</span><br><span class="line">            String weaverAwareName = var3[var5];</span><br><span class="line">            this.getBean(weaverAwareName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">// 停止使用临时的类加载器</span><br><span class="line">        beanFactory.setTempClassLoader((ClassLoader)null);</span><br><span class="line">        </span><br><span class="line">        // 缓存所有的 beanDefinition 数据，防止更改，实际上是将 beanDefinitionNames 进行备份</span><br><span class="line">        //  this.frozenBeanDefinitionNames = StringUtils.toStringArray(this.beanDefinitionNames)</span><br><span class="line">        beanFactory.freezeConfiguration();</span><br><span class="line">        </span><br><span class="line">        // 实例化所有的单例的bean (非 Lazy) </span><br><span class="line">        beanFactory.preInstantiateSingletons();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><br></p><h3 id="finishRefresh"><a href="#finishRefresh" class="headerlink" title="finishRefresh()"></a>finishRefresh()</h3><p>finishRefresh() 的作用是做 refesh() 后的额外操作，例如清除上下文缓存 ( ASM 数据 )，初始化 生命周期处理器 LifeCycleProcessor，发布 上下文已经刷新事件 ContextRefreshedEvent.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">AbstractApplicationContext.class</span><br><span class="line">protected void finishRefresh() &#123;</span><br><span class="line">// 清除 context level 的资源缓存，例如扫描中的 ASM 数据</span><br><span class="line">        this.clearResourceCaches();</span><br><span class="line">        </span><br><span class="line">        // 初始化 LifeCycleProcessor，和 initApplicationEventMulticaster 差不多，先检查本地，否者创建注册</span><br><span class="line">        this.initLifecycleProcessor();</span><br><span class="line">        </span><br><span class="line">        // 调用所有 LifeCycleBean 的 start()</span><br><span class="line">        this.getLifecycleProcessor().onRefresh();</span><br><span class="line">        </span><br><span class="line">        // 完成上下文刷新后，发布 ContextRefeshedEvent 上下文刷新事件</span><br><span class="line">        this.publishEvent((ApplicationEvent)(new ContextRefreshedEvent(this)));</span><br><span class="line">        </span><br><span class="line">        // 如果设置了 JMX 属性，那么将进行注册</span><br><span class="line">        LiveBeansView.registerApplicationContext(this);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>可以看出，refresh() 在 SpringBoot 的启动过程中，扮演着非常重要的角色，包括了注册重要的 bean 组件，实例化容器中的 bean，processors 之间的调用等，通过分析后，我们可以了解到了我们日常工作中使用到的各种实现例如 InstantiationAwareBeanPostProcessor ，Listener, LifeCycleProcessor 等组件的调用顺序及功能。</p><p>同时，refresh() 过程也很好的展示了 bean 的生命周期中各个组件的位置及作用，也对于我们理解 Spring 容器有了更好的理解。</p><p><img src="/images/springboot/bean-life-cycle.png" alt></p><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><ul><li><a href="https://juejin.im/post/5cc25d6ef265da036d79c11a" target="_blank" rel="noopener">聊聊国际化MessageSource</a></li><li><a href="https://blog.csdn.net/f641385712/article/details/88041409" target="_blank" rel="noopener">Spring IOC容器启动流程</a></li><li><a href="http://fangjian0423.github.io/2017/05/10/springboot-context-refresh/" target="_blank" rel="noopener">SpringBoot源码分析之Spring容器的refresh过程</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;refresh&quot;&gt;&lt;a href=&quot;#refresh&quot; class=&quot;headerlink&quot; title=&quot;refresh()&quot;&gt;&lt;/a&gt;refresh()&lt;/h2&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;上一篇分析 &lt;code&gt;SpringBoot&lt;/code&gt; 启动过程中的 构造过程及 &lt;code&gt;run()&lt;/code&gt;，在构造的过程中，主要是根据应用程序的类型设置 &lt;code&gt;WebApplicationType&lt;/code&gt;，同时根据 &lt;code&gt;spring.factories&lt;/code&gt;的配置读取初始化容器的一些监听器 &lt;code&gt;listeners&lt;/code&gt; 和初始化器 &lt;code&gt;initializers&lt;/code&gt;。  &lt;/p&gt;
&lt;p&gt;而在 &lt;code&gt;run()&lt;/code&gt;中，主要是对应用上下文 &lt;code&gt;ApplicationContext&lt;/code&gt; 创建并进行初始化，设置 &lt;code&gt;WebApplicationType&lt;/code&gt;对应的 &lt;code&gt;environment&lt;/code&gt;，然后 &lt;code&gt;refreshContext(context)&lt;/code&gt; ，最后加载 &lt;code&gt;listeners start(),running&lt;/code&gt; 并加入 &lt;code&gt;SpringRunners&lt;/code&gt;.  &lt;/p&gt;
&lt;p&gt;在 &lt;code&gt;refreshContext(context)&lt;/code&gt; 主要有下面几个工作：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#prepareRefresh&quot;&gt;prepareRefresh()&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#prepareBeanFactory&quot;&gt;prepareBeanFactory()&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#postProcessBeanFactory&quot;&gt;postProcessBeanFactory()&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#invokeBeanFactoryPostProcessors&quot;&gt;invokeBeanFactoryPostProcessors()&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#registerBeanPostProcessors&quot;&gt;registerBeanPostProcessors()&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#initMessageSource&quot;&gt;initMessageSource()&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#initApplicationEventMulticaster&quot;&gt;initApplicationEventMulticaster()&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#onRefresh&quot;&gt;onRefresh()&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#registerListeners&quot;&gt;registerListeners()&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#finishBeanFactoryInitialization&quot;&gt;finishBeanFactoryInitialization()&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#finishRefresh&quot;&gt;finishRefresh()&lt;/a&gt;&lt;br&gt;&lt;br&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;50&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;51&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;52&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;  public void refresh() throws BeansException, IllegalStateException &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 获取监视器锁&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      synchronized(this.startupShutdownMonitor) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      	// 刷新上下文前的准备，记录状态，验证必要属性&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          this.prepareRefresh();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          ConfigurableListableBeanFactory beanFactory = this.obtainFreshBeanFactory();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          // 配置标准的 beanFactory，设置 classloader, bean表达解析器，同时注册重要的bean组件&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          this.prepareBeanFactory(beanFactory);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          try &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          	// 模板方法，交由子类对 beanFactory 进行后置处理&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;              this.postProcessBeanFactory(beanFactory);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;              &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;              // 调用 beanFactoryPostPorcessor &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;              this.invokeBeanFactoryPostProcessors(beanFactory);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;              &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;              // 注册容器中的 beanPostProcessors&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;              this.registerBeanPostProcessors(beanFactory);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;              &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;              // 初始化国际工具类 MessageSource&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;              this.initMessageSource();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;              &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;              // 初始化并注册事件广播器 ApplicationEventMulticaster&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;              this.initApplicationEventMulticaster();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;              &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;              // 模板方法，根据应用的具体类型交由子类具体处理，如果是web类型，通常是构建webServer&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;              this.onRefresh();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;              &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;              // 注册容器中的监听器，包括spring.factories 和 自定义 bean listenr&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;              this.registerListeners();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;              &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;              // 实例化所有的单例 bean （非 Lazy）,beanPostProcessor 开始起作用&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;              this.finishBeanFactoryInitialization(beanFactory);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;              &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;              // refresh() 后的额外工作，包括清除resource cahce，注册 LifeCycleProcessor及发布上下文已经刷新的事件 ContexntRefreshedEvent&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;              this.finishRefresh();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          &amp;#125; catch (BeansException var9) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		// 如果刷新上下文的过程中，出现异常，那么销毁所有已经创建的 bean&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;              this.destroyBeans();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;              &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;              // 重置 context 的刷新状态，即将 active = false&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;              this.cancelRefresh(var9);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;              throw var9;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          &amp;#125; finally &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          	// 无论失败与否，已经不再需要 bean metadata，重置 Spring 的内核缓存&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;              this.resetCommonCaches();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Spring" scheme="https://heiku.github.io/tags/Spring/"/>
    
      <category term="SpringBoot" scheme="https://heiku.github.io/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot启动过程-run()</title>
    <link href="https://heiku.github.io/2019/10/12/SpringBoot%E5%90%AF%E5%8A%A8%E5%88%86%E6%9E%90-run/"/>
    <id>https://heiku.github.io/2019/10/12/SpringBoot启动分析-run/</id>
    <published>2019-10-12T13:42:31.000Z</published>
    <updated>2019-10-14T12:56:26.981Z</updated>
    
    <content type="html"><![CDATA[<h2 id="SpringApplication-run"><a href="#SpringApplication-run" class="headerlink" title="SpringApplication.run()"></a>SpringApplication.run()</h2><p>在上一篇中，我们分析了 <code>SpringBoot</code> 启动过程中的 <code>@SpringBootApplocation</code> ，其主要功能就是加载对应的 <code>@Configuration</code> 及 <code>Auto Configure</code> 模块中的组件信息，并将组件内容加入到容器中。</p><p>这篇将开始分析 <code>SpringBoot</code> 的启动过程，而启动过程中最核心的两个部分就是 <code>SpringApplication 的启动过程</code> 及 <code>SpringApplication 的 run 方法</code> ，下面为分析过程：</p><h3 id="SpringApplication-的构造函数"><a href="#SpringApplication-的构造函数" class="headerlink" title="SpringApplication 的构造函数"></a>SpringApplication 的构造函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public SpringApplication(ResourceLoader resourceLoader, Class&lt;?&gt;... primarySources) &#123;</span><br><span class="line">    ...</span><br><span class="line">    // 设置启动的源Class，即启动的SpringBootLearningApplication.class对象，包含了对应的 classLoader</span><br><span class="line">        this.primarySources = new LinkedHashSet(Arrays.asList(primarySources));</span><br><span class="line">        </span><br><span class="line">        // 设置了 webApplication的类型，尚未配置web，所以当前为 NONE （Servlet, Reactive）</span><br><span class="line">        this.webApplicationType = WebApplicationType.deduceFromClasspath();</span><br><span class="line">        </span><br><span class="line">        // 借助 SpringFactoriesLoader 找到 /META-INF/spring.factories 下的所有配置 key 为 ApplicationContextInitializer </span><br><span class="line">          （所有的应用初始化器），实例化并设置到 setInitializers 这个集合属性中</span><br><span class="line">        this.setInitializers(this.getSpringFactoriesInstances(ApplicationContextInitializer.class));</span><br><span class="line">        </span><br><span class="line">        // 和上面一样， 通过 SpringFactoriesLoader 找到所有配置 key 为 ApplicationListener (所有的应用程序监听器)，</span><br><span class="line">            实例化并设置到 setListeners 集合属性中</span><br><span class="line">        this.setListeners(this.getSpringFactoriesInstances(ApplicationListener.class));</span><br><span class="line">        </span><br><span class="line">       // 找到 StackTrace （方法调用堆栈）中的 main 方法，即入口类的名字，并 Class.forName 得到类对象</span><br><span class="line">        this.mainApplicationClass = this.deduceMainApplicationClass();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><br></p><h3 id="ApplicationEvent"><a href="#ApplicationEvent" class="headerlink" title="ApplicationEvent"></a>ApplicationEvent</h3><p><code>SpringBoot</code> 中使用了很多 <code>Event</code> 去响应容器状态，而 <code>ApplicationEvent</code> 为多个组件 bean 提供了消息通信的支持，其中就包括了接下来在 <code>run( )</code> 使用到的 <code>SpringApplicationEvent</code> ,它实现了全局的 <code>base ApplicationEvent</code>，并扩展为多个 Spring 启动中的事件 Event，如下：</p><ol><li><strong>ApplicationContextInitializedEvent</strong>  </li><li><strong>ApplicationEnvironmentPreparedEvent</strong>  </li><li><strong>ApplicationPreparedEvent</strong></li><li><strong>ApplicationStartedEvent</strong></li><li><strong>ApplicationReadyEvent</strong></li><li><strong>ApplicationFailedEvent</strong></li><li><strong>ApplicationStartingEvent</strong></li></ol><p><img src="/images/springboot/spring-boot-extend-applicationEvent.png" alt></p><p><br></p><p><strong>事件的传递过程如下：</strong></p><ol><li>SpringApplicationRunListener 调用对应的操作如 ( starting, running, contextLoad… )</li><li>SpringApplicationRunListener 内部针对不同的事件，遍历内部集合调用对应的方法，具体实现类为 EventPublishingRunListener 调用</li><li>EventPublishingRunListener  将对应的操作 ( starting, environmentPrepared.. ) 封装成对应的事件并通过属性 initialMulticaster push 广播出去</li><li>最后广播出去的事件如 ( ApplicationStartingEvent ) 会被 SpringApplication 中的 listeners 属性监听处理</li></ol><p><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// SpringApplication.class</span><br><span class="line">public ConfigurableApplicationContext run(String... args) &#123;</span><br><span class="line">listeners.starting();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// SpringApplicationRunListeners </span><br><span class="line">public void starting() &#123;</span><br><span class="line">        Iterator var1 = this.listeners.iterator();</span><br><span class="line"></span><br><span class="line">        while(var1.hasNext()) &#123;</span><br><span class="line">            SpringApplicationRunListener listener = (SpringApplicationRunListener)var1.next();</span><br><span class="line">            listener.starting();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// EventPublishingRunListeners.class</span><br><span class="line">public void starting() &#123;</span><br><span class="line">        this.initialMulticaster.multicastEvent(new ApplicationStartingEvent(this.application, this.args));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p><br></p><p><strong>EventPublishingRunListener 具体操作事件的广播推送如下：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"> // EventPublishingRunListener 事件推送监听器</span><br><span class="line"> </span><br><span class="line"> // Spring 启动, run()的时候立即运行，ApplicationStartingEvent</span><br><span class="line"> public void starting() &#123;</span><br><span class="line">       this.initialMulticaster.multicastEvent(new ApplicationStartingEvent(this.application, this.args));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   // 环境信息准备好并准备创建 ApplicationContext 之前, ApplicationEnvironmentPreparedEvent</span><br><span class="line">   public void environmentPrepared(ConfigurableEnvironment environment) &#123;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">//ApplicationContext 创建完成，并准备加载 source时调用, ApplicationPreparedEvent</span><br><span class="line">   public void contextPrepared(ConfigurableApplicationContext context) &#123;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">// ApplicationContext 已经创建并加载，在 refresh() 之前调用, ApplicationPreparedEvent</span><br><span class="line">   public void contextLoaded(ConfigurableApplicationContext context) &#123;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   // Application refresh()后，容器正式启动, ApplicationStartedEvent</span><br><span class="line">   public void started(ConfigurableApplicationContext context) &#123;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">// Spring 正式运行， ApplicationReadyEvent</span><br><span class="line">   public void running(ConfigurableApplicationContext context) &#123;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">// 当运行失败时， ApplicationFailedEvent</span><br><span class="line">   public void failed(ConfigurableApplicationContext context, Throwable exception) &#123;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><br></p><h3 id="SpringApplication-run-1"><a href="#SpringApplication-run-1" class="headerlink" title="SpringApplication.run()"></a>SpringApplication.run()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">public ConfigurableApplicationContext run(String... args) &#123;</span><br><span class="line">    // 启动 StopWatch，开始记录任务的执行时间</span><br><span class="line">        StopWatch stopWatch = new StopWatch();</span><br><span class="line">        stopWatch.start();</span><br><span class="line">        </span><br><span class="line">        // 定义 context</span><br><span class="line">        ConfigurableApplicationContext context = null;</span><br><span class="line">        Collection&lt;SpringBootExceptionReporter&gt; exceptionReporters = new ArrayList();</span><br><span class="line">        </span><br><span class="line">        // 配置 System Property java.awt.headless = true，用于控制台下的调试</span><br><span class="line">        this.configureHeadlessProperty();</span><br><span class="line">        </span><br><span class="line">        // 获取 SpringApplicationRunListeners，实例为 EventPublishingRunListener</span><br><span class="line">        SpringApplicationRunListeners listeners = this.getRunListeners(args);</span><br><span class="line">        </span><br><span class="line">        // 封装SpringApplicationEvent，即 ApplicationStartingEvent 进行广播推送</span><br><span class="line">        listeners.starting();</span><br><span class="line"></span><br><span class="line">   // 定义异常集合，用后于catch &amp;&amp; handle</span><br><span class="line">        Collection exceptionReporters;</span><br><span class="line">        try &#123;</span><br><span class="line">        </span><br><span class="line">        // 创建应用程序参数类</span><br><span class="line">            ApplicationArguments applicationArguments = new DefaultApplicationArguments(args);</span><br><span class="line">            </span><br><span class="line">            // 根据 WebType 创建 对应的 Environment 对象，用于获取 properties,profile</span><br><span class="line">            // 同时EventPublishingRunListeners 广播 ApplicationEnvironmentPreparedEvent</span><br><span class="line">            ConfigurableEnvironment environment = this.prepareEnvironment(listeners, applicationArguments);</span><br><span class="line">            </span><br><span class="line">            // 在 Environment对象中配置需要忽略的 bean 信息</span><br><span class="line">            this.configureIgnoreBeanInfo(environment);</span><br><span class="line">            </span><br><span class="line">            // 打印 banner</span><br><span class="line">            Banner printedBanner = this.printBanner(environment);</span><br><span class="line">            </span><br><span class="line">            // 创建 ApplicationContext (AnnotationConfigApplicationContext)</span><br><span class="line">            // 通过 WebType 得到对应的 ApplicationContextClass，通过反射的到对应的ApplicationContext </span><br><span class="line">            context = this.createApplicationContext();</span><br><span class="line">            </span><br><span class="line">            // 通过 SpringFactoriesLoader 获取配置key的 SpringBoot异常报告器</span><br><span class="line">            exceptionReporters = this.getSpringFactoriesInstances(SpringBootExceptionReporter.class, new Class[]&#123;ConfigurableApplicationContext.class&#125;, context);</span><br><span class="line">            </span><br><span class="line">            // ApplicationContext pre handle</span><br><span class="line">            // 1.为Context 设置 environment</span><br><span class="line">            // 2.为之前加载的 AppplicationInitializers 遍历 initialize(context)，进行上下文初始化</span><br><span class="line">            // 3.创建SpringDefinitionLoader，用于加载 xml 或 JavaConfig 中的bean</span><br><span class="line">            this.prepareContext(context, environment, listeners, applicationArguments, printedBanner);</span><br><span class="line">            </span><br><span class="line">            // 刷新应用上下文 ApplicationContext</span><br><span class="line">            this.refreshContext(context);</span><br><span class="line">            </span><br><span class="line">            // 刷新上下文后的额外操作</span><br><span class="line">            this.afterRefresh(context, applicationArguments);</span><br><span class="line">            </span><br><span class="line">            // 停止时间计时</span><br><span class="line">            stopWatch.stop();</span><br><span class="line">            if (this.logStartupInfo) &#123;</span><br><span class="line">                (new StartupInfoLogger(this.mainApplicationClass)).logStarted(this.getApplicationLog(), stopWatch);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">   // 启动加载的 listener list</span><br><span class="line">            listeners.started(context);</span><br><span class="line">            </span><br><span class="line">            // 添加 ApplicationRunners 和 CommandLineRunners 相关的 Runners </span><br><span class="line">            this.callRunners(context, applicationArguments);</span><br><span class="line">        &#125; catch (Throwable var10) &#123;</span><br><span class="line">        // 这里用于处理之前捕获的异常集合</span><br><span class="line">            this.handleRunFailure(context, var10, exceptionReporters, listeners);</span><br><span class="line">            throw new IllegalStateException(var10);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">        // 启动加载的 listener list</span><br><span class="line">            listeners.running(context);</span><br><span class="line">            return context;</span><br><span class="line">        &#125; catch (Throwable var9) &#123;</span><br><span class="line">            this.handleRunFailure(context, var9, exceptionReporters, (SpringApplicationRunListeners)null);</span><br><span class="line">            throw new IllegalStateException(var9);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><br></p><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>启动 <code>Spring Boot</code> 的过程大致分为两部分，一部分为：<code>SpringApplication 的构造过程</code> 和 <code>SpringApplication.run() 具体的运行过程</code>  </p><p><strong>SpringApplication</strong> 的构造方法主要有以下过程：</p><ol><li>获取并设置 primarySources， 即程序的入口 Class</li><li>获取设置 webApplicationType</li><li>通过 <strong>SpringFactoriesLoader</strong> ，加载 spring.factories 中的 Initializers ，找到所有初始化器，并设置属性</li><li>同理，找到所有的应用程序监听器，并设置到 Listeners 属性中</li><li>找到运行的 <code>main</code> 主类，并设置到属性 mainApplicationClass</li></ol><p><strong>SpringApplication run()</strong> 的执行过程如下：</p><ol><li>启动 StopWatch，开始记录任务的执行时间</li><li>定义 <code>ApplicationContext</code>，并通过 <code>EventPublishingRunListeners</code> 广播 <code>ApplicationStartingEvent</code> 事件，事件将会被加载的 <code>listeners</code> 监听并处理</li><li>创建应用参数类 ApplicationArguments 及根据 WebApplicationType 创建对应的 Environment，用于记录系统中的 Properties</li><li>创建 ApplicationContext</li><li>进行 <code>prepareContext</code>，对 context 设置environment，并遍历加载的 <code>initializer</code> 初始化 context，最后创建 <code>SpringDefinitionLoader</code></li><li><code>refreshContext</code>，完成 bean 的解析，开启 processor 接口等工作</li><li>加载的 listeners 进行 start(), running()，同时加入 SpringRunners</li></ol><p><br></p><p><strong>参考</strong></p><p><a href="http://fangjian0423.github.io/2017/04/30/springboot-startup-analysis/" target="_blank" rel="noopener">SpringBoot源码分析之SpringBoot的启动过程</a><br><a href="http://www.jerome.xin/articles/spring-boot-startup-execution-process" target="_blank" rel="noopener">Spring Boot 启动深究SpringApplication执行流程</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;SpringApplication-run&quot;&gt;&lt;a href=&quot;#SpringApplication-run&quot; class=&quot;headerlink&quot; title=&quot;SpringApplication.run()&quot;&gt;&lt;/a&gt;SpringApplication.run()&lt;/h2&gt;&lt;p&gt;在上一篇中，我们分析了 &lt;code&gt;SpringBoot&lt;/code&gt; 启动过程中的 &lt;code&gt;@SpringBootApplocation&lt;/code&gt; ，其主要功能就是加载对应的 &lt;code&gt;@Configuration&lt;/code&gt; 及 &lt;code&gt;Auto Configure&lt;/code&gt; 模块中的组件信息，并将组件内容加入到容器中。&lt;/p&gt;
&lt;p&gt;这篇将开始分析 &lt;code&gt;SpringBoot&lt;/code&gt; 的启动过程，而启动过程中最核心的两个部分就是 &lt;code&gt;SpringApplication 的启动过程&lt;/code&gt; 及 &lt;code&gt;SpringApplication 的 run 方法&lt;/code&gt; ，下面为分析过程：&lt;/p&gt;
&lt;h3 id=&quot;SpringApplication-的构造函数&quot;&gt;&lt;a href=&quot;#SpringApplication-的构造函数&quot; class=&quot;headerlink&quot; title=&quot;SpringApplication 的构造函数&quot;&gt;&lt;/a&gt;SpringApplication 的构造函数&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;public SpringApplication(ResourceLoader resourceLoader, Class&amp;lt;?&amp;gt;... primarySources) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	    ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	    // 设置启动的源Class，即启动的SpringBootLearningApplication.class对象，包含了对应的 classLoader&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        this.primarySources = new LinkedHashSet(Arrays.asList(primarySources));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        // 设置了 webApplication的类型，尚未配置web，所以当前为 NONE （Servlet, Reactive）&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        this.webApplicationType = WebApplicationType.deduceFromClasspath();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        // 借助 SpringFactoriesLoader 找到 /META-INF/spring.factories 下的所有配置 key 为 ApplicationContextInitializer &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          （所有的应用初始化器），实例化并设置到 setInitializers 这个集合属性中&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        this.setInitializers(this.getSpringFactoriesInstances(ApplicationContextInitializer.class));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        // 和上面一样， 通过 SpringFactoriesLoader 找到所有配置 key 为 ApplicationListener (所有的应用程序监听器)，&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            实例化并设置到 setListeners 集合属性中&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        this.setListeners(this.getSpringFactoriesInstances(ApplicationListener.class));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       // 找到 StackTrace （方法调用堆栈）中的 main 方法，即入口类的名字，并 Class.forName 得到类对象&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        this.mainApplicationClass = this.deduceMainApplicationClass();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h3 id=&quot;ApplicationEvent&quot;&gt;&lt;a href=&quot;#ApplicationEvent&quot; class=&quot;headerlink&quot; title=&quot;ApplicationEvent&quot;&gt;&lt;/a&gt;ApplicationEvent&lt;/h3&gt;&lt;p&gt;&lt;code&gt;SpringBoot&lt;/code&gt; 中使用了很多 &lt;code&gt;Event&lt;/code&gt; 去响应容器状态，而 &lt;code&gt;ApplicationEvent&lt;/code&gt; 为多个组件 bean 提供了消息通信的支持，其中就包括了接下来在 &lt;code&gt;run( )&lt;/code&gt; 使用到的 &lt;code&gt;SpringApplicationEvent&lt;/code&gt; ,它实现了全局的 &lt;code&gt;base ApplicationEvent&lt;/code&gt;，并扩展为多个 Spring 启动中的事件 Event，如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;ApplicationContextInitializedEvent&lt;/strong&gt;  &lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ApplicationEnvironmentPreparedEvent&lt;/strong&gt;  &lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ApplicationPreparedEvent&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ApplicationStartedEvent&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ApplicationReadyEvent&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ApplicationFailedEvent&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ApplicationStartingEvent&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;/images/springboot/spring-boot-extend-applicationEvent.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;事件的传递过程如下：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;SpringApplicationRunListener 调用对应的操作如 ( starting, running, contextLoad… )&lt;/li&gt;
&lt;li&gt;SpringApplicationRunListener 内部针对不同的事件，遍历内部集合调用对应的方法，具体实现类为 EventPublishingRunListener 调用&lt;/li&gt;
&lt;li&gt;EventPublishingRunListener  将对应的操作 ( starting, environmentPrepared.. ) 封装成对应的事件并通过属性 initialMulticaster push 广播出去&lt;/li&gt;
&lt;li&gt;最后广播出去的事件如 ( ApplicationStartingEvent ) 会被 SpringApplication 中的 listeners 属性监听处理&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;// SpringApplication.class&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;public ConfigurableApplicationContext run(String... args) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	listeners.starting();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// SpringApplicationRunListeners &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;public void starting() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Iterator var1 = this.listeners.iterator();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        while(var1.hasNext()) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            SpringApplicationRunListener listener = (SpringApplicationRunListener)var1.next();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            listener.starting();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// EventPublishingRunListeners.class&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;public void starting() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        this.initialMulticaster.multicastEvent(new ApplicationStartingEvent(this.application, this.args));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Spring" scheme="https://heiku.github.io/tags/Spring/"/>
    
      <category term="SpringBoot" scheme="https://heiku.github.io/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot启动过程 - @SpringBootApplication</title>
    <link href="https://heiku.github.io/2019/10/10/SpringBoot%E5%90%AF%E5%8A%A8%E5%88%86%E6%9E%90-@SpringBootApplication/"/>
    <id>https://heiku.github.io/2019/10/10/SpringBoot启动分析-@SpringBootApplication/</id>
    <published>2019-10-10T11:48:56.000Z</published>
    <updated>2019-10-11T02:03:40.823Z</updated>
    
    <content type="html"><![CDATA[<p><strong>SpringBoot 的启动过程如下：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">public class SpringbootlLearningApplication &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(SpringbootlLearningApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  SpringBoot 简化了大量的配置的信息，几行代码就将 Spring Boot 服务启动，具体观察一下，有两部分指的注意：</p><ol><li>@SpringBootApplication 注解去指定启动类</li><li>SpringApplication.run(SpringbootLearingApplication.class, args)  启动 Spring 容器</li></ol><p><br></p><h2 id="SpringBootApplication"><a href="#SpringBootApplication" class="headerlink" title="@SpringBootApplication"></a>@SpringBootApplication</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@Target(&#123;ElementType.TYPE&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">@Inherited</span><br><span class="line">@SpringBootConfiguration</span><br><span class="line">@EnableAutoConfiguration</span><br><span class="line">@ComponentScan(</span><br><span class="line">    excludeFilters = &#123;@Filter(</span><br><span class="line">    type = FilterType.CUSTOM,</span><br><span class="line">    classes = &#123;TypeExcludeFilter.class&#125;</span><br><span class="line">), @Filter(</span><br><span class="line">    type = FilterType.CUSTOM,</span><br><span class="line">    classes = &#123;AutoConfigurationExcludeFilter.class&#125;</span><br><span class="line">)&#125;</span><br><span class="line">)</span><br><span class="line">public @interface SpringBootApplication &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这里 <strong>@SpringBootApplication</strong> 是一个组合注解，它包含了以下三个重要的注解：</p><ol><li><strong>@SpringBootConfiguration</strong></li><li><strong>@EnableAutoConfiguration</strong></li><li><strong>@ComponentScan</strong></li></ol><p><br></p><h4 id="SpringBootConfiguration"><a href="#SpringBootConfiguration" class="headerlink" title="@SpringBootConfiguration"></a>@SpringBootConfiguration</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Target(&#123;ElementType.TYPE&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">@Configuration</span><br><span class="line">public @interface SpringBootConfiguration &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，<a href="https://docs.spring.io/spring-boot/docs/current/api/org/springframework/boot/SpringBootConfiguration.html" target="_blank" rel="noopener">@SpringBootConfiguration</a> 实际上就是一个配置注解，与 @Configuration 不同的是，一个应用程序中只能使用一个 @SpringBootConfiguration，而在我们启动 SpringBootApplication 的时候就已经开启配置，而 @Configuration 可以根据需要进行 JavaConfig 的方式进行多个实例配置</p><p><br></p><h3 id="EnableAutoConfiguration"><a href="#EnableAutoConfiguration" class="headerlink" title="@EnableAutoConfiguration"></a>@EnableAutoConfiguration</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Target(&#123;ElementType.TYPE&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">@Inherited</span><br><span class="line">@AutoConfigurationPackage</span><br><span class="line">@Import(&#123;AutoConfigurationImportSelector.class&#125;)</span><br><span class="line">public @interface EnableAutoConfiguration &#123;</span><br><span class="line">    String ENABLED_OVERRIDE_PROPERTY = &quot;spring.boot.enableautoconfiguration&quot;;</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt;[] exclude() default &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    String[] excludeName() default &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@EnableAutoConfiguration这个复合annotation 的主要作用是开启容器的自动配置功能，而具体由 @AutoConfigurationPackage 和 @Import({AutoConfigurationImportSelector.class}) 实现。  </p><a id="more"></a><p><br></p><h4 id="AutoConfigurationPackage"><a href="#AutoConfigurationPackage" class="headerlink" title="@AutoConfigurationPackage"></a>@AutoConfigurationPackage</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@Target(&#123;ElementType.TYPE&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">@Inherited</span><br><span class="line">@Import(&#123;Registrar.class&#125;)</span><br><span class="line">public @interface AutoConfigurationPackage &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    static class Registrar implements ImportBeanDefinitionRegistrar, DeterminableImports &#123;</span><br><span class="line">        Registrar() &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void registerBeanDefinitions(AnnotationMetadata metadata, BeanDefinitionRegistry registry) &#123;</span><br><span class="line">            AutoConfigurationPackages.register(registry, (new AutoConfigurationPackages.PackageImport(metadata)).getPackageName());// 注册组件bean信息</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public Set&lt;Object&gt; determineImports(AnnotationMetadata metadata) &#123;</span><br><span class="line">            return Collections.singleton(new AutoConfigurationPackages.PackageImport(metadata));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><br></p><p><strong>AutoConfigurationPackages.Register</strong> 会向 Spring 容器中注册所有包下的的组件Bean 信息，例如：我们自定义一个 Bean</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class HelloService &#123;</span><br><span class="line"></span><br><span class="line">    void sayHello()&#123;</span><br><span class="line">        System.out.println(&quot;hello&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Debug 的时候就会发现，我们自定义的 component HelloService 被加入到 BeanDefinitionMap中，准备进行注入容器中</p><p><img src="/images/springboot/springboot-autoconfigurationpackage.png" alt></p><h4 id="Import-AutoConfigurationImportSelector-class"><a href="#Import-AutoConfigurationImportSelector-class" class="headerlink" title="@Import({AutoConfigurationImportSelector.class})"></a>@Import({AutoConfigurationImportSelector.class})</h4><p>@Import({AutoConfigurationImportSelector.class}) 这个注解主要是借助 @Import 的帮助，将符合自动配置 auto configure 的bean加载到容器中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">AutoConfigurationImportSelector.class</span><br><span class="line"></span><br><span class="line">    protected List&lt;String&gt; getCandidateConfigurations(AnnotationMetadata metadata, AnnotationAttributes attributes) &#123;</span><br><span class="line">    // 这里获取了 auto configurate的所有类文件名</span><br><span class="line">        List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(this.getSpringFactoriesLoaderFactoryClass(), this.getBeanClassLoader());</span><br><span class="line">        Assert.notEmpty(configurations, &quot;No auto configuration classes found in META-INF/spring.factories. If you are using a custom packaging, make sure that file is correct.&quot;);</span><br><span class="line">        return configurations;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="/images/springboot/springboot-getCandidateConfigurations.png" alt></p><p><br><br>加载这些 auto configurate 的类文件主要是借助于 <strong>SpringFactoriesLoader</strong> 进行实现的，SpringFactoriesLoader 会根据 配置的key即（@EnableAutoConfiguration 的路径，为 <strong>org.springframework.boot.autoconfigure</strong>）下，找到指定的配置文件如 <strong>META-INF/spring.factories</strong> 加载对应的 auto configure class，并加入到容器中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># Auto Configure</span><br><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</span><br><span class="line">org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.cassandra.CassandraAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.cloud.CloudServiceConnectorsAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.context.ConfigurationPropertiesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.context.MessageSourceAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.context.PropertyPlaceholderAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.couchbase.CouchbaseAutoConfiguration,\</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><br></p><h3 id="ComponentScan"><a href="#ComponentScan" class="headerlink" title="@ComponentScan"></a>@ComponentScan</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Target(&#123;ElementType.TYPE&#125;)</span><br><span class="line">@Documented</span><br><span class="line">@Repeatable(ComponentScans.class)</span><br><span class="line">public @interface ComponentScan &#123;</span><br><span class="line">    @AliasFor(&quot;basePackages&quot;)</span><br><span class="line">    String[] value() default &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    @AliasFor(&quot;value&quot;)</span><br><span class="line">    String[] basePackages() default &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt;[] basePackageClasses() default &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    Class&lt;? extends BeanNameGenerator&gt; nameGenerator() default BeanNameGenerator.class;</span><br><span class="line"></span><br><span class="line">    Class&lt;? extends ScopeMetadataResolver&gt; scopeResolver() default AnnotationScopeMetadataResolver.class;</span><br><span class="line"></span><br><span class="line">    ScopedProxyMode scopedProxy() default ScopedProxyMode.DEFAULT;</span><br><span class="line"></span><br><span class="line">    String resourcePattern() default &quot;**/*.class&quot;;</span><br><span class="line"></span><br><span class="line">    boolean useDefaultFilters() default true;</span><br><span class="line"></span><br><span class="line">    ComponentScan.Filter[] includeFilters() default &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    ComponentScan.Filter[] excludeFilters() default &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    boolean lazyInit() default false;</span><br><span class="line"></span><br><span class="line">    @Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">    @Target(&#123;&#125;)</span><br><span class="line">    public @interface Filter &#123;</span><br><span class="line">        FilterType type() default FilterType.ANNOTATION;</span><br><span class="line"></span><br><span class="line">        @AliasFor(&quot;classes&quot;)</span><br><span class="line">        Class&lt;?&gt;[] value() default &#123;&#125;;</span><br><span class="line"></span><br><span class="line">        @AliasFor(&quot;value&quot;)</span><br><span class="line">        Class&lt;?&gt;[] classes() default &#123;&#125;;</span><br><span class="line"></span><br><span class="line">        String[] pattern() default &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@ComponentScan 这个注解的主要功能就是自动扫描并加载符合条件的组件，如 @Component 和 @Repository，并将组件加入到容器中，根据属性配置 basePackage可以指定扫描的范围 </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;SpringBoot 的启动过程如下：&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;@SpringBootApplication&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;public class SpringbootlLearningApplication &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    public static void main(String[] args) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        SpringApplication.run(SpringbootlLearningApplication.class, args);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;  SpringBoot 简化了大量的配置的信息，几行代码就将 Spring Boot 服务启动，具体观察一下，有两部分指的注意：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;@SpringBootApplication 注解去指定启动类&lt;/li&gt;
&lt;li&gt;SpringApplication.run(SpringbootLearingApplication.class, args)  启动 Spring 容器&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;SpringBootApplication&quot;&gt;&lt;a href=&quot;#SpringBootApplication&quot; class=&quot;headerlink&quot; title=&quot;@SpringBootApplication&quot;&gt;&lt;/a&gt;@SpringBootApplication&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;@Target(&amp;#123;ElementType.TYPE&amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@Retention(RetentionPolicy.RUNTIME)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@Documented&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@Inherited&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@SpringBootConfiguration&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@EnableAutoConfiguration&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@ComponentScan(&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    excludeFilters = &amp;#123;@Filter(&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    type = FilterType.CUSTOM,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    classes = &amp;#123;TypeExcludeFilter.class&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;), @Filter(&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    type = FilterType.CUSTOM,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    classes = &amp;#123;AutoConfigurationExcludeFilter.class&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;)&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;public @interface SpringBootApplication &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;可以看到，这里 &lt;strong&gt;@SpringBootApplication&lt;/strong&gt; 是一个组合注解，它包含了以下三个重要的注解：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;@SpringBootConfiguration&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;@EnableAutoConfiguration&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;@ComponentScan&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h4 id=&quot;SpringBootConfiguration&quot;&gt;&lt;a href=&quot;#SpringBootConfiguration&quot; class=&quot;headerlink&quot; title=&quot;@SpringBootConfiguration&quot;&gt;&lt;/a&gt;@SpringBootConfiguration&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;@Target(&amp;#123;ElementType.TYPE&amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@Retention(RetentionPolicy.RUNTIME)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@Documented&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@Configuration&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;public @interface SpringBootConfiguration &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;可以看出，&lt;a href=&quot;https://docs.spring.io/spring-boot/docs/current/api/org/springframework/boot/SpringBootConfiguration.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;@SpringBootConfiguration&lt;/a&gt; 实际上就是一个配置注解，与 @Configuration 不同的是，一个应用程序中只能使用一个 @SpringBootConfiguration，而在我们启动 SpringBootApplication 的时候就已经开启配置，而 @Configuration 可以根据需要进行 JavaConfig 的方式进行多个实例配置&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h3 id=&quot;EnableAutoConfiguration&quot;&gt;&lt;a href=&quot;#EnableAutoConfiguration&quot; class=&quot;headerlink&quot; title=&quot;@EnableAutoConfiguration&quot;&gt;&lt;/a&gt;@EnableAutoConfiguration&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;@Target(&amp;#123;ElementType.TYPE&amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@Retention(RetentionPolicy.RUNTIME)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@Documented&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@Inherited&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@AutoConfigurationPackage&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@Import(&amp;#123;AutoConfigurationImportSelector.class&amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;public @interface EnableAutoConfiguration &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    String ENABLED_OVERRIDE_PROPERTY = &amp;quot;spring.boot.enableautoconfiguration&amp;quot;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Class&amp;lt;?&amp;gt;[] exclude() default &amp;#123;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    String[] excludeName() default &amp;#123;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;@EnableAutoConfiguration这个复合annotation 的主要作用是开启容器的自动配置功能，而具体由 @AutoConfigurationPackage 和 @Import({AutoConfigurationImportSelector.class}) 实现。  &lt;/p&gt;
    
    </summary>
    
    
      <category term="Spring" scheme="https://heiku.github.io/tags/Spring/"/>
    
      <category term="SpringBoot" scheme="https://heiku.github.io/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>Zero-Copy</title>
    <link href="https://heiku.github.io/2019/09/23/Zero-Copy/"/>
    <id>https://heiku.github.io/2019/09/23/Zero-Copy/</id>
    <published>2019-09-23T08:32:43.000Z</published>
    <updated>2019-10-10T14:17:24.270Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Linux-Zero-Copy"><a href="#Linux-Zero-Copy" class="headerlink" title="Linux Zero-Copy"></a>Linux Zero-Copy</h2><h3 id="什么是零拷贝"><a href="#什么是零拷贝" class="headerlink" title="什么是零拷贝 ?"></a>什么是零拷贝 ?</h3><p><strong>Zero Copy</strong> 是一种避免 CPU 将数据从一块存储拷贝到另一块存储的技术。 <strong>Zero Copy</strong> 可以减少数据拷贝和共享总线操作的次数，消除传输数据再存储器之间不必要的拷贝次数，从而有效地提高数据传输地效率。</p><h3 id="Linux-IO-Copy"><a href="#Linux-IO-Copy" class="headerlink" title="Linux IO Copy"></a>Linux IO Copy</h3><ul><li>read() &amp;&amp; write()</li></ul><p>  当我们在访问一个网页的时候，在 Web Server (Linux) 会调用一下两个 文件读写函数：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">read(fd, buffer, len);</span><br><span class="line">write(sockfd, buffer, len);</span><br></pre></td></tr></table></figure><p>  <img src="../images/zeroCopy/no-zero-copy.png" alt></p><p>  <strong>过程分析：</strong></p><ol><li><p>调用 read()，将具体的磁盘文件数据读取到 内核（kernel）的文件系统缓冲区中</p></li><li><p>接着是将 内核缓存区的数据 <strong>拷贝到</strong> 用户的缓冲区中</p></li><li><p>调用 write()，将用户缓冲区的数据写入到 <strong>内核 socket</strong> 的发送缓存区中</p></li><li><p>在 write() 返回后，内核会将 socket 发送区的数据拷贝到 网卡驱动中</p></li></ol><p>  <strong>性能分析</strong>：</p><p>  这个过程中，一共发生了四次 <strong>I/O copy</strong>， 这期间数据按照 kernel -&gt; user -&gt; kernel -&gt; hard drive 的路线，在 <strong>内核</strong> 到 <strong>用户</strong> 白白消耗了一圈的 性能开销，同时除了考虑 I/O 的性能开销，还要考虑系统 context switch 带来的开销，当系统调用 read() 时，系统会从 <strong>用户态</strong> 切换到 <strong>内核态</strong>，当 read() 返回时，又需要将 <strong>内核态</strong> 切换到 <strong>用户态</strong>，同理，write() 也会导致两次的 context switch，也就是说 read() 和 write() 总共会导致 4次的 I/O copy 和 4次上下文切换。</p><ul><li><p>sendfile()</p><p>而采用 sendfile（）可减少在 read() &amp; write() 所产生的多次 I/O 拷贝和 context switch</p></li></ul>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sendfile(sockfd, fd, NULL, len);</span><br></pre></td></tr></table></figure><p>  <img src="/images/zeroCopy/zero-copy-two-cpoy.png" alt></p><p>  <strong>过程分析：</strong></p><ol><li><p>将磁盘中的文件数据拷贝到 内核中的文件缓冲区</p></li><li><p>向 socket buffer 中 <strong>追加</strong> 当前的数据在 kernel buffer 中的位置和偏移量</p></li><li><p>根据 socket buffer 中的位置和偏移量，将 kernel buffer 中的数据 <strong>copy</strong> 到 网卡驱动中</p></li></ol><p>  <strong>性能分析：</strong></p><p>  这次过程中，sendfile() 相比于 read() &amp; write() ，对于将要发送的数据 (socket) ，采用的是记录下对应的 数据在 kernel buffer 中的 <strong>位置和偏移量</strong>，在最后要发送 socket buffer的数据到网卡设备时，只需通过 位置及偏移量 找到对应 kernel buffer的数据。相比于 <strong>read / write</strong>， 少了两次 I/O copy，和两次 context switch，性能有了很大的提升。</p><p><strong>总结</strong></p><p>为什么说是 <strong>zero-copy</strong> 呢？ 因为在 sendfile() 调用的过程中，对于内核 kernel ，整个过程中是零拷贝的，不涉及 内核到用户之间的数据拷贝。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Linux-Zero-Copy&quot;&gt;&lt;a href=&quot;#Linux-Zero-Copy&quot; class=&quot;headerlink&quot; title=&quot;Linux Zero-Copy&quot;&gt;&lt;/a&gt;Linux Zero-Copy&lt;/h2&gt;&lt;h3 id=&quot;什么是零拷贝&quot;&gt;&lt;a hr
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://heiku.github.io/tags/Linux/"/>
    
      <category term="Zero-Copy" scheme="https://heiku.github.io/tags/Zero-Copy/"/>
    
  </entry>
  
  <entry>
    <title>IO Model</title>
    <link href="https://heiku.github.io/2019/09/18/IO-Model/"/>
    <id>https://heiku.github.io/2019/09/18/IO-Model/</id>
    <published>2019-09-18T10:56:14.000Z</published>
    <updated>2019-10-10T14:17:37.693Z</updated>
    
    <content type="html"><![CDATA[<h2 id="I-O-模型"><a href="#I-O-模型" class="headerlink" title="I / O 模型"></a>I / O 模型</h2><p>I / O 模型的概念大概有：阻塞 / 非阻塞 / 同步 / 异步</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">一个用户进程发起 I/O 请求的例子：</span><br><span class="line"></span><br><span class="line">Linux内核会将所有的外部设备当作一个文件来操作，与外部设备的交互均可等同于对文件进行操作。</span><br><span class="line">即文件的读写都是通过系统调用进行的。</span><br><span class="line"></span><br><span class="line">Linux内核通过 file descriptor处理本地文件的读写， socket file descriptor 处理 Socket 网络读写</span><br><span class="line">那么， I/O将会涉及两个系统对象，一个是调用它的用户线程(or thread)，另一个是系统内核 (kernel)</span><br><span class="line"></span><br><span class="line">一个读写操作：</span><br><span class="line">1. 用户进程调用 read 方法向内核发起读请求b并等待就绪</span><br><span class="line">2. 内核将要读取的数据复制到文件描述所指向的内核缓存区 （系统准备 IO 数据）</span><br><span class="line">3. 内核将数据从内核缓存区复制到用户的进程空间</span><br></pre></td></tr></table></figure><h3 id="阻塞-vs-非阻塞"><a href="#阻塞-vs-非阻塞" class="headerlink" title="阻塞  vs  非阻塞"></a>阻塞  vs  非阻塞</h3><ul><li><p><strong>阻塞 ( Blocking IO )</strong>：用户发起 I/O 操作后，需要等待其操作完成之后才能继续运行</p><ul><li>特点：阻塞式 I/O 模型简单。易于理解，但性能差，会照成用户 CPU 大量闲置</li><li>优化：可以采用多线程的方式进行请求调用，但并不能解决根本问题</li></ul></li></ul><p>  <img src="../images/io/blocking-io.png" alt></p><ul><li><p><strong>非阻塞 ( No-Blocking IO )</strong>：用户进程发起 I/O 操作后，无需等待操作完成，会直接返回调用结果，即如果数据没有准备好，会直接返回失败，这就需要用户进程要定期轮询 I/O 是否就绪</p><ul><li>特点：能立即得到返回结果，当使用一个线程去处理 socket 请求，可以极大减少线程数量。但用户线程会不断轮询会增加额外的 CPU 的资源开销</li></ul></li></ul><p>  <img src="../images/io/non-blocking-io.png" alt></p><ul><li>总结：阻塞 IO 与 非阻塞 IO 的本质区别主要在于 用户程序是否再等待调用结果（继续等待还是得到结果先处理其他事情）</li></ul><h3 id="同步-IO-vs-异步-IO"><a href="#同步-IO-vs-异步-IO" class="headerlink" title="同步 IO vs 异步 IO"></a>同步 IO vs 异步 IO</h3><ul><li><strong>同步 IO ( Synchronous IO )</strong> ：当系统内核将处理数据操作准备完毕之后，会主动读取内核数据，用户进程需要等待内核将数据复制到用户进程之后，再进行处理</li></ul><ul><li><p><strong>IO 多路复用 ( IO- Multiplexing )</strong>：可以监视多个描述符，一旦某个描述符读写操作就绪，就可以通知程序进行相应的读写操作</p><p>应用：Linux中使用的 I/O 多路复用机制：select， poll，epoll ( event driven IO），尽管实现的方式不同，但都属于同步 IO，它们都需要在读写事件就绪后，再自己进行读写的操作，内核向用户进程复制数据的过程仍然是阻塞的。</p></li></ul><ul><li>特点：尽管使用了事件驱动判断就绪，但与 Blocking-IO 并没有什么太大的不同，甚至在读取的过程中，因为会使用到两个 system call ( select， recvfrom)，相比于 blocking-io 的一个 recvfrom，可能在连接数不高的情况下，性能会更差。但有了 select 的优势就在于系统可以同时处理多个 connnection，效率更高。</li></ul><p>  <img src="../images/io/io-multiplexing.png" alt></p><ul><li><strong>异步 IO ( Asynchronous IO )</strong> : 当用户进程发起 IO 请求后，会直接返回请求成功，等到再接受到内核的 signal 通知的时候， IO 操作已经完成了</li></ul><ul><li><p><strong>非阻塞 ( no-blocking io ) vs 异步io ( asynchronous io )</strong></p><p><strong>no-blocking io</strong>：虽然大部分时间都不会 block （loop check data ready），但内核数据准备好之后，还是需要主动调用 recvfrom 系统调用进行数据的复制，这期间 process block</p><p><strong>asynchronous io</strong>：整个过程会将任务交由内核处理，直到 IO done，才会向用户进程发送信号通知成功</p></li></ul><p>  <img src="../images/io/Asynchronous-io.png" alt></p><ul><li>总结：同步 IO 和 异步 IO的本质区别在于内核数据 复制到 用户空间的时候用户线程是否阻塞等待</li></ul><ul><li><strong>大总结</strong></li></ul><p>  <img src="../images/io/five-io-model.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;I-O-模型&quot;&gt;&lt;a href=&quot;#I-O-模型&quot; class=&quot;headerlink&quot; title=&quot;I / O 模型&quot;&gt;&lt;/a&gt;I / O 模型&lt;/h2&gt;&lt;p&gt;I / O 模型的概念大概有：阻塞 / 非阻塞 / 同步 / 异步&lt;/p&gt;
&lt;figure clas
      
    
    </summary>
    
    
      <category term="IO" scheme="https://heiku.github.io/tags/IO/"/>
    
      <category term="同步 vs 异步" scheme="https://heiku.github.io/tags/%E5%90%8C%E6%AD%A5-vs-%E5%BC%82%E6%AD%A5/"/>
    
      <category term="阻塞 vs 非阻塞" scheme="https://heiku.github.io/tags/%E9%98%BB%E5%A1%9E-vs-%E9%9D%9E%E9%98%BB%E5%A1%9E/"/>
    
      <category term="Linux" scheme="https://heiku.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Java泛型-协变与逆变</title>
    <link href="https://heiku.github.io/2019/07/17/Java%E6%B3%9B%E5%9E%8B-%E5%8D%8F%E5%8F%98%E4%B8%8E%E9%80%86%E5%8F%98/"/>
    <id>https://heiku.github.io/2019/07/17/Java泛型-协变与逆变/</id>
    <published>2019-07-17T14:30:27.000Z</published>
    <updated>2019-10-10T11:43:16.313Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><strong>协变与逆变 (Covariance and contravariance )</strong> 用来描述具有父/子关系的类型通过类型转换之后的继承关系。  </p><p>即：如果A、B表示类型，f()表示类型转换， 表示子类与父类之间的继承关系，那么有以下定义：<br><strong>协变(Covariance)</strong>：当 A $\subseteq$ B时，f(A) $\subseteq$ f(B)成立；<br><strong>逆变(contravariance)</strong>：当A $\subseteq$ B时，f(B) $\subseteq$ f(A)成立；<br><strong>不变(invariance)</strong>：当A $\subseteq$ B时，以上均不成立，那么f(A)与f(B)之间不存在继承关系；</p><p>先定义几个类之间的继承关系</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Fruit&#123;&#125;       // base</span><br><span class="line"></span><br><span class="line">class Apple extends Fruit&#123;&#125;</span><br><span class="line"></span><br><span class="line">class Lemon extends Fruit&#123;&#125;</span><br><span class="line">class Eureka extends Lemon&#123;&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="数组是协变的"><a href="#数组是协变的" class="headerlink" title="数组是协变的"></a>数组是协变的</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Fruit[] fruit = new Lemon[20];</span><br><span class="line"></span><br><span class="line">fruit[0] = new Lemon();</span><br><span class="line">fruit[1] = new Eureka();</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line">    fruit[2] = new Fruit();</span><br><span class="line">&#125;catch (Exception e)&#123;</span><br><span class="line">    System.out.println(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">java.lang.ArrayStoreException: Baisc.type.generic.Fruit</span><br></pre></td></tr></table></figure><p>首先，创建的数组为 Lemon 数组，同时在栈中创建一个 fruit 的引用指向 lemon[]。因为实际数组为 Lemon Class，所以我们可以放入 Lemon 及子类 Eureka，而当我们将 Fruit 基类放入时，排除类型异常，因为并不是所有 Fruit 都属于 Lemon。</p><p>那么，为什么编译器不会发现问题呢？因为编译器会将在存储表中标识fruit是Fruit[]类型，所以编译期间通过，但在运行中才会去判断数组元素的类型约束。</p><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>为了解决这中问题，Java从引入泛型去解决编译期间的类型转换问题。但事实上，Java中的泛型不像 C++中的 <strong>模板泛型</strong> 一样，是真实的模板实例，十分灵活易于拓展。相反，而是一种语法糖，在编译期间会进行 <strong>类型擦除</strong>，最终都会替换成 <strong>非泛型上界</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Lemon&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">在编译期间都会进行类型擦除，最终都会转为 class java.util.ArrayList 这样无类型的集合类</span><br></pre></td></tr></table></figure><h2 id="So，泛型是不变的"><a href="#So，泛型是不变的" class="headerlink" title="So，泛型是不变的"></a>So，泛型是不变的</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">List&lt;Fruit&gt; list = new ArrayList&lt;Apple&gt;();     // 编译错误</span><br><span class="line"></span><br><span class="line">正因为泛型在编译期间进行了类型擦除，所以在编译期间会统一类型，所以会在编译期间提示错误。</span><br></pre></td></tr></table></figure><p>那么，如果我想表示这种类型转换的话，那该怎么办？这时就需要通配符。</p><h2 id="泛型中的通配符和边界"><a href="#泛型中的通配符和边界" class="headerlink" title="泛型中的通配符和边界"></a>泛型中的通配符和边界</h2><ul><li><strong>&lt; ? extend T &gt;</strong>: 上界通配符 ( Upper Bounds Wildcards )</li><li><strong>&lt; ? super T &gt;</strong>: 下界通配符 ( Lower Bounds Wildcards )</li></ul><h3 id="上界"><a href="#上界" class="headerlink" title="上界"></a>上界</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">List&lt;? extends Fruit&gt; = new ArrayList&lt;Lemon&gt;();      // 编译成功</span><br></pre></td></tr></table></figure><p><strong>为什么说是上界通配符呢？</strong>  </p><p>我们把之前列出的几个类通过一颗继承关系树表示，将会得到下面的结果：</p><p><img src="../images/generic/泛型-上界.png" alt></p><p><strong>&lt;? extend Fruit&gt;</strong> 指明了泛型的上界为Fruit，在上面的例子中，&lt; ? extends Fruit &gt; 表示了一个能装水果或者属于水果的盘子。即放得下 List&lt; Fruit &gt; 以及 List&lt; Lemon &gt;的基类。</p><h3 id="下界"><a href="#下界" class="headerlink" title="下界"></a>下界</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">List&lt;? super Fruit&gt; list = new ArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure><p><img src="../images/generic/泛型-下界.png" alt></p><p>下界表示的是一个相反的概念，表示的是当前的 list能存放的是 Fruit的基类。</p><h3 id="PECS-原则"><a href="#PECS-原则" class="headerlink" title="PECS 原则"></a>PECS 原则</h3><p><strong>producer extends,consumer super  —《Effective Java》</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">List&lt;? extends Fruit&gt; list = new ArrayList&lt;Lemon&gt;();</span><br><span class="line"></span><br><span class="line">Object object = list.get(0);</span><br><span class="line">Fruit fruit = list.get(1);</span><br><span class="line">Lemon lemon = list.get(2);      // 1 编译错误</span><br><span class="line"></span><br><span class="line">list.add(new Lemon());          // 2 编译错误</span><br><span class="line">list.add(new Fruit());          // 3 编译错误</span><br></pre></td></tr></table></figure><p><strong>&lt; ? extends Fruit &gt; 只能存，不能放</strong></p><ul><li>get( ) : extends 规定了容器的上界，所以容器中获取的类型只能是 Fruit 或是 它的基类即 Object。</li><li>set( ) : 由于编译器不知道 List&lt;? extends Fruit&gt; 到底指的是什么类型，有可能是 Apple， 也有可能是 Lemon，所以会先在 List上打上标识符：<strong>CAP#1</strong>，表示捕获一个 Fruit 或 Fruit的子类，但却没有具体的类型可以与这个 <strong>CAP#1</strong> 进行匹配，所以在执行这种向上转型的时候，将散失其中传递对象的能力。  </li></ul><p>类比于数组，当我们将 Lemon[] 向上转型为 Fruit[]的时候，在运行期间往数组中添加 fruit会抛出异常，而泛型的时候，就是将这种类型检查移到编译期间，拒绝一切不安全的类型协变。</p><p><strong>&lt; ? super Fruit &gt; 只能放，不能读</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">List&lt;? super Fruit&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">list.add(new Eureka());</span><br><span class="line">list.add(new Lemon());</span><br><span class="line">list.add(new Fruit());</span><br><span class="line"></span><br><span class="line">Lemon lemon = list.get(0);      // 编译失败</span><br><span class="line">Fruit fruit = list.get(0);      // 编译失败</span><br><span class="line">    </span><br><span class="line">Object obj = list.get(0);</span><br></pre></td></tr></table></figure><ul><li>get ( ) : 下界规定了 List 存放的 元素的最小粒度的下限，即元素既然是 Fruit的基类，那么往里面放力度比 Fruit的都可以。</li><li>set ( ) : 由于类型丢失，导致存放的时候只有 基类 Object才能放下。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;协变与逆变 (Covariance and contravariance )&lt;/strong&gt; 用来描述具有父/子关系的类型通过类型转换之后的继承关系。  &lt;/p&gt;
&lt;p&gt;即：如果A、B表示类型，f()表示类型转换， 表示子类与父类之间的继承关系，那么有以下定义：&lt;br&gt;&lt;strong&gt;协变(Covariance)&lt;/strong&gt;：当 A $\subseteq$ B时，f(A) $\subseteq$ f(B)成立；&lt;br&gt;&lt;strong&gt;逆变(contravariance)&lt;/strong&gt;：当A $\subseteq$ B时，f(B) $\subseteq$ f(A)成立；&lt;br&gt;&lt;strong&gt;不变(invariance)&lt;/strong&gt;：当A $\subseteq$ B时，以上均不成立，那么f(A)与f(B)之间不存在继承关系；&lt;/p&gt;
&lt;p&gt;先定义几个类之间的继承关系&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;class Fruit&amp;#123;&amp;#125;       // base&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;class Apple extends Fruit&amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;class Lemon extends Fruit&amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;class Eureka extends Lemon&amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://heiku.github.io/tags/Java/"/>
    
      <category term="泛型" scheme="https://heiku.github.io/tags/%E6%B3%9B%E5%9E%8B/"/>
    
      <category term="协变与逆变" scheme="https://heiku.github.io/tags/%E5%8D%8F%E5%8F%98%E4%B8%8E%E9%80%86%E5%8F%98/"/>
    
  </entry>
  
  <entry>
    <title>Decorator pattern</title>
    <link href="https://heiku.github.io/2018/08/31/%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>https://heiku.github.io/2018/08/31/装饰者模式/</id>
    <published>2018-08-31T15:31:48.000Z</published>
    <updated>2019-09-18T10:44:59.755Z</updated>
    
    <content type="html"><![CDATA[<p><strong>概念</strong></p><p>在面向对象的编程中，装饰器模式是一种设计模式，它允许动态地将行为添加到单个对象，而不会影响来自同一类的其他对象的行为。</p><p><strong>举例</strong></p><p>当我们在需要扩展一个类的方法的时候，我们需要不断地继承原始方法或上一级方法的类，加上新的方法结构，这样就实现了对于原始方法的增强。当继承关系复杂的情景下，当我们要修改其中一个类方法，会导致其他增强方法的重写，这样使代码的耦合性太强，维护成本很高。对于这种情况，我们可以试试使用装饰者模式去解决这个问题。</p><p>就以我们最经常看到的IO操作中，构造一个InputStreamReader，File读取path封装成FileInputStream，接着被装饰成InputStreamReader</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">InputStreamReader reader = new InputStreamReader(new FileInputStream(new File(path)));</span><br></pre></td></tr></table></figure><a id="more"></a><p><strong>组成</strong></p><p>Component接口：抽象组件，即最原始的方法，底层方法。</p><p>ConcreteComponent类：实现了Component接口，具体的被装饰组件。</p><p>Decorator类：抽象继承类，是所有装饰者的父类。内部有一个私有的Component类型的属性，在构造方法中初始化属性，对底层的方法做了封装。</p><p>ConcreteDecorator类：具体的装饰者类，继承Decorator类。每一个ConcreteDecorator类都会有自己的私有方法（方法增强），接着通过在重写父类方法，在重写方法中添加自身方法，从而达到了新的功能的效果。</p><p><strong>举例</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Created by Heiku on 2018/8/31</span><br><span class="line"> *</span><br><span class="line"> * Decorator pattern</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">// 抽象手机功能</span><br><span class="line">interface PhoneFunc&#123;</span><br><span class="line"></span><br><span class="line">    void shoot();</span><br><span class="line">    void play();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 手机的具体实现</span><br><span class="line">class SimplePhone implements PhoneFunc&#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void shoot() &#123;</span><br><span class="line">        System.out.println(&quot;我可以拍摄&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void play() &#123;</span><br><span class="line">        System.out.println(&quot;我可以播放音乐&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 抽象装饰者</span><br><span class="line">abstract class Decorator implements PhoneFunc&#123;</span><br><span class="line"></span><br><span class="line">    // 被装饰的PhoneFunc</span><br><span class="line">    private PhoneFunc phoneFunc;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    // 通过构造器注入装饰的phoneFunc</span><br><span class="line">    public Decorator(PhoneFunc phoneFunc)&#123;</span><br><span class="line">        this.phoneFunc = phoneFunc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void shoot() &#123;</span><br><span class="line">        this.phoneFunc.shoot();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void play() &#123;</span><br><span class="line">        this.phoneFunc.play();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 继承抽象装饰者</span><br><span class="line">class ShootPhone extends Decorator&#123;</span><br><span class="line"></span><br><span class="line">    public ShootPhone(PhoneFunc phoneFunc)&#123;</span><br><span class="line">        super(phoneFunc);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 自己新加的功能</span><br><span class="line">    private void exposure()&#123;</span><br><span class="line">        System.out.println(&quot;拍摄曝光处理&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void shoot() &#123;</span><br><span class="line">        super.shoot();</span><br><span class="line">        exposure();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class BeautyPhone extends Decorator&#123;</span><br><span class="line"></span><br><span class="line">    public BeautyPhone(PhoneFunc phoneFunc)&#123;</span><br><span class="line">        super(phoneFunc);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 自己新加的功能</span><br><span class="line">    private void Beauty()&#123;</span><br><span class="line">        System.out.println(&quot;拍摄美颜处理&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void shoot() &#123;</span><br><span class="line">        super.shoot();</span><br><span class="line">        Beauty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Phone &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        BeautyPhone beautyPhone = new BeautyPhone(new ShootPhone(new SimplePhone()));</span><br><span class="line">        beautyPhone.shoot();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Reuslt:</span><br><span class="line">我可以拍摄</span><br><span class="line">拍摄曝光处理</span><br><span class="line">拍摄美颜处理</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;概念&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在面向对象的编程中，装饰器模式是一种设计模式，它允许动态地将行为添加到单个对象，而不会影响来自同一类的其他对象的行为。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;举例&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当我们在需要扩展一个类的方法的时候，我们需要不断地继承原始方法或上一级方法的类，加上新的方法结构，这样就实现了对于原始方法的增强。当继承关系复杂的情景下，当我们要修改其中一个类方法，会导致其他增强方法的重写，这样使代码的耦合性太强，维护成本很高。对于这种情况，我们可以试试使用装饰者模式去解决这个问题。&lt;/p&gt;
&lt;p&gt;就以我们最经常看到的IO操作中，构造一个InputStreamReader，File读取path封装成FileInputStream，接着被装饰成InputStreamReader&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;InputStreamReader reader = new InputStreamReader(new FileInputStream(new File(path)));&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="https://heiku.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Strategy pattern</title>
    <link href="https://heiku.github.io/2018/07/31/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
    <id>https://heiku.github.io/2018/07/31/策略模式/</id>
    <published>2018-07-30T16:13:01.000Z</published>
    <updated>2019-09-19T10:10:00.059Z</updated>
    
    <content type="html"><![CDATA[<p><strong>概念</strong></p><p>在计算机编程中，策略模式是一种行为 软件设计模式，可以在运行时选择算法。代码不是直接实现单个算法，而是接收关于在一系列算法中使用哪些算法的运行时指令。</p><p><strong>举例</strong></p><p>策略模式可以说是一种选择，它会根据调用者的属性去调用对应的算法，动态地改变对象的行为，用户可以调正对应的策略达到想要的目的。下面会举一个策略模式的Demo场景，同时将分析 Spring 中的策略模式。</p><p><strong>组成</strong></p><p>Context：一般提供setStrategy(strategy)，用于设置对应的策略，同时起到封装的作用，屏蔽直接访问实际策略。</p><p>Srategy：strategy公共接口，规定了策略的属性，方法</p><p>ConcreteStrategy：实际策略类，实现了接口，根据具体策略实现对应的算法。</p><a id="more"></a><p><strong>举例</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Created by Heiku on 2018/7/31</span><br><span class="line"> *</span><br><span class="line"> * Strategy pattern</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">// 策略接口 购买手机的客户</span><br><span class="line">interface Client&#123;</span><br><span class="line">    void introduct();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 果粉</span><br><span class="line">class AppleFans implements Client&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void introduct() &#123;</span><br><span class="line">        System.out.println(&quot;向果粉介绍苹果新产品&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 游戏玩家</span><br><span class="line">class Gamer implements Client&#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void introduct() &#123;</span><br><span class="line">        System.out.println(&quot;向手机玩家介绍 黑鲨等游戏手机&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 学生党</span><br><span class="line">class Student implements Client&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void introduct() &#123;</span><br><span class="line">        System.out.println(&quot;向学生党介绍最新发布的手机&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 手机城</span><br><span class="line">public class PhoneShop &#123;</span><br><span class="line">    private Client client = null;</span><br><span class="line"></span><br><span class="line">    public void setClient(Client client) &#123;</span><br><span class="line">        this.client = client;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void introduct()&#123;</span><br><span class="line">        client.introduct();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        PhoneShop shop = new PhoneShop();</span><br><span class="line"></span><br><span class="line">        // 果粉进店</span><br><span class="line">        System.out.println(&quot;果粉进店&quot;);</span><br><span class="line">        shop.setClient(new AppleFans());</span><br><span class="line">        shop.introduct();</span><br><span class="line"></span><br><span class="line">        // 游戏发烧友进店</span><br><span class="line">        System.out.println(&quot;游戏发烧友进店&quot;);</span><br><span class="line">        shop.setClient(new Gamer());</span><br><span class="line">        shop.introduct();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        // 学生党进店</span><br><span class="line">        System.out.println(&quot;学生党进店&quot;);</span><br><span class="line">        shop.setClient(new Student());</span><br><span class="line">        shop.introduct();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 结果</span><br><span class="line">果粉进店</span><br><span class="line">向果粉介绍苹果新产品</span><br><span class="line">游戏发烧友进店</span><br><span class="line">向手机玩家介绍 黑鲨等游戏手机</span><br><span class="line">学生党进店</span><br><span class="line">向学生党介绍最新发布的手机</span><br></pre></td></tr></table></figure><p><strong>Spring中的实际应用</strong></p><p>在 SpringMVC中，当启动服务器时，request进来时，DispatcherSerlvet作为请求入口，会依次调用HttpServletBean -&gt; FrameworkServlet -&gt; DispatcherServlet,完成容器的初始化，注意几个servlet是向上的继承关系.</p><p>在FrameworkServlet中会调用 initWebApplicationContext（）-&gt; onRefresh()</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">protected WebApplicationContext initWebApplicationContext() &#123;</span><br><span class="line">    ...</span><br><span class="line">    if (!this.refreshEventReceived) &#123;</span><br><span class="line">            this.onRefresh(wac);</span><br><span class="line">        &#125;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>接着，在DispatcherServlet时，会进行bean的初始化，调用onRefresh() -&gt; initStrategies()，进行九大组件的初始化</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 刷新容器时，将策略更新</span><br><span class="line">protected void onRefresh(ApplicationContext context) &#123;</span><br><span class="line">        this.initStrategies(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 进行初始化策略</span><br><span class="line">    protected void initStrategies(ApplicationContext context) &#123;</span><br><span class="line">        this.initMultipartResolver(context);</span><br><span class="line">        this.initLocaleResolver(context);</span><br><span class="line">        this.initThemeResolver(context);</span><br><span class="line">        this.initHandlerMappings(context);</span><br><span class="line">        this.initHandlerAdapters(context);</span><br><span class="line">        this.initHandlerExceptionResolvers(context);</span><br><span class="line">        this.initRequestToViewNameTranslator(context);</span><br><span class="line">        this.initViewResolvers(context);</span><br><span class="line">        this.initFlashMapManager(context);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>根据context上下文，获取对应策略</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 获取对应策略</span><br><span class="line">protected &lt;T&gt; T getDefaultStrategy(ApplicationContext context, Class&lt;T&gt; strategyInterface) &#123;</span><br><span class="line">        List&lt;T&gt; strategies = this.getDefaultStrategies(context, strategyInterface);</span><br><span class="line">        if (strategies.size() != 1) &#123;</span><br><span class="line">            throw new BeanInitializationException(&quot;DispatcherServlet needs exactly 1 strategy for interface [&quot; + strategyInterface.getName() + &quot;]&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return strategies.get(0);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">protected &lt;T&gt; List&lt;T&gt; getDefaultStrategies(ApplicationContext context, Class&lt;T&gt; strategyInterface) &#123;</span><br><span class="line">        String key = strategyInterface.getName();</span><br><span class="line">        String value = defaultStrategies.getProperty(key);</span><br><span class="line">        if (value == null) &#123;</span><br><span class="line">            return new LinkedList();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            String[] classNames = StringUtils.commaDelimitedListToStringArray(value);</span><br><span class="line">            List&lt;T&gt; strategies = new ArrayList(classNames.length);</span><br><span class="line">            String[] var7 = classNames;</span><br><span class="line">            int var8 = classNames.length;</span><br><span class="line"></span><br><span class="line">            for(int var9 = 0; var9 &lt; var8; ++var9) &#123;</span><br><span class="line">                String className = var7[var9];  </span><br><span class="line">                try &#123;</span><br><span class="line">                    Class&lt;?&gt; clazz = ClassUtils.forName(className, DispatcherServlet.class.getClassLoader());</span><br><span class="line">                    Object strategy = this.createDefaultStrategy(context, clazz);</span><br><span class="line">                    strategies.add(strategy);</span><br><span class="line">                &#125; catch (ClassNotFoundException var13) &#123;</span><br><span class="line">                    throw new BeanInitializationException(&quot;Could not find DispatcherServlet&apos;s default strategy class [&quot; + className + &quot;] for interface [&quot; + key + &quot;]&quot;, var13);</span><br><span class="line">                &#125; catch (LinkageError var14) &#123;</span><br><span class="line">                    throw new BeanInitializationException(&quot;Error loading DispatcherServlet&apos;s default strategy class [&quot; + className + &quot;] for interface [&quot; + key + &quot;]: problem with class file or dependent class&quot;, var14);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            return strategies;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;概念&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在计算机编程中，策略模式是一种行为 软件设计模式，可以在运行时选择算法。代码不是直接实现单个算法，而是接收关于在一系列算法中使用哪些算法的运行时指令。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;举例&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;策略模式可以说是一种选择，它会根据调用者的属性去调用对应的算法，动态地改变对象的行为，用户可以调正对应的策略达到想要的目的。下面会举一个策略模式的Demo场景，同时将分析 Spring 中的策略模式。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;组成&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Context：一般提供setStrategy(strategy)，用于设置对应的策略，同时起到封装的作用，屏蔽直接访问实际策略。&lt;/p&gt;
&lt;p&gt;Srategy：strategy公共接口，规定了策略的属性，方法&lt;/p&gt;
&lt;p&gt;ConcreteStrategy：实际策略类，实现了接口，根据具体策略实现对应的算法。&lt;/p&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="https://heiku.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="Spring的源码分析" scheme="https://heiku.github.io/tags/Spring%E7%9A%84%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>Abstract factory pattern</title>
    <link href="https://heiku.github.io/2018/07/29/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    <id>https://heiku.github.io/2018/07/29/抽象工厂模式/</id>
    <published>2018-07-28T16:49:45.000Z</published>
    <updated>2019-09-19T10:10:40.344Z</updated>
    
    <content type="html"><![CDATA[<p><strong>概念</strong></p><p>抽象工厂模式 提供了一种方式封装一组独立的工厂有一个共同的主题，而无需指定他们的具体类，即提供接口，用于创建相关或依赖对象的类。</p><p><strong>举例</strong></p><p>之前提到了 工厂方法模式，区分这两种模式的点在于 工厂方法 -&gt; 单一产品，而 抽象工厂 -&gt; 产品族，对于下面的例子，组件工厂类可以抽分为两种工厂，分别为生成高质量组件的工厂(HighQualityFactory) 和 生成廉价组件的工厂(LowQualityFactory)，工厂生成的是产品族，一个工厂可以生成多种类别的组件，根据组件的高质量 或 廉价 两种属性确定对应的工厂。</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Created by Heiku on 2018/7/28</span><br><span class="line"> *</span><br><span class="line"> * model : Abstract factory pattern</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 组件接口</span><br><span class="line">interface PhoneComponents&#123;</span><br><span class="line"></span><br><span class="line">    // 组件质量</span><br><span class="line">    PhoneComponents quailty();</span><br><span class="line">    // 组件获取</span><br><span class="line">    PhoneComponents get();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 摄像头</span><br><span class="line">abstract class CameraComponent implements PhoneComponents&#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public PhoneComponents get() &#123;</span><br><span class="line">        System.out.println(&quot;get CameraComponent&quot;);</span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 屏幕</span><br><span class="line">abstract class ScreenComponent implements PhoneComponents&#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public PhoneComponents get() &#123;</span><br><span class="line">        System.out.println(&quot;get ScreenComponent&quot;);</span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 处理器</span><br><span class="line">abstract class ProcessorComponent implements PhoneComponents&#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public PhoneComponents get() &#123;</span><br><span class="line">        System.out.println(&quot;get ProcessorComponent&quot;);</span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 高质量 摄像头</span><br><span class="line">class HighQuailtyCamera extends CameraComponent&#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public PhoneComponents quailty() &#123;</span><br><span class="line">        System.out.println(&quot;this is high quality camera&quot;);</span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 低质量 摄像头</span><br><span class="line">class  LowQualityCamera extends CameraComponent&#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public PhoneComponents quailty() &#123;</span><br><span class="line">        System.out.println(&quot;this is low quality camera&quot;);</span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 高质量 屏幕</span><br><span class="line">class HighQualityScreen extends ScreenComponent&#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public PhoneComponents quailty() &#123;</span><br><span class="line">        System.out.println(&quot;this is high quality screen&quot;);</span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 低质量 摄像头</span><br><span class="line">class LowQualityScreen extends ScreenComponent&#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public PhoneComponents quailty() &#123;</span><br><span class="line">        System.out.println(&quot;this is low quality screen&quot;);</span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 高质量 处理器</span><br><span class="line">class HighQualityProcessor extends ProcessorComponent&#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public PhoneComponents quailty() &#123;</span><br><span class="line">        System.out.println(&quot;this is high quality processor&quot;);</span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 低质量 处理器</span><br><span class="line">class LowQualityProcessor extends  ProcessorComponent&#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public PhoneComponents quailty() &#123;</span><br><span class="line">        System.out.println(&quot;this is low quality processor&quot;);</span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!--more--><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">// 抽象工厂</span><br><span class="line">interface Factory&#123;</span><br><span class="line"></span><br><span class="line">    PhoneComponents productCamera();</span><br><span class="line">    PhoneComponents productScreen();</span><br><span class="line">    PhoneComponents productProcessor();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 实体 高级工厂（负责生产高质量产品）</span><br><span class="line">class HighQualityFactory implements Factory&#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public PhoneComponents productCamera() &#123;</span><br><span class="line">        return new HighQuailtyCamera();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public PhoneComponents productScreen() &#123;</span><br><span class="line">        return new HighQualityScreen();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public PhoneComponents productProcessor() &#123;</span><br><span class="line">        return new HighQualityProcessor();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 实体 低级工厂（负责生成廉价产品）</span><br><span class="line">class LowQualityFactory implements Factory&#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public PhoneComponents productCamera() &#123;</span><br><span class="line">        return new LowQualityCamera();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public PhoneComponents productScreen() &#123;</span><br><span class="line">        return new LowQualityScreen();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public PhoneComponents productProcessor() &#123;</span><br><span class="line">        return new LowQualityProcessor();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class PhoneShop &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Factory highFactory = new HighQualityFactory();</span><br><span class="line">        Factory lowFactory = new LowQualityFactory();</span><br><span class="line"></span><br><span class="line">        // 不同工厂生成</span><br><span class="line">        highFactory.productCamera().quailty();</span><br><span class="line">        lowFactory.productScreen().quailty();</span><br><span class="line"></span><br><span class="line">        highFactory.productScreen().quailty();</span><br><span class="line">        lowFactory.productScreen().quailty();</span><br><span class="line"></span><br><span class="line">        highFactory.productProcessor().quailty();</span><br><span class="line">        lowFactory.productProcessor().quailty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;概念&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;抽象工厂模式 提供了一种方式封装一组独立的工厂有一个共同的主题，而无需指定他们的具体类，即提供接口，用于创建相关或依赖对象的类。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;举例&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;之前提到了 工厂方法模式，区分这两种模式的点在于 工厂方法 -&amp;gt; 单一产品，而 抽象工厂 -&amp;gt; 产品族，对于下面的例子，组件工厂类可以抽分为两种工厂，分别为生成高质量组件的工厂(HighQualityFactory) 和 生成廉价组件的工厂(LowQualityFactory)，工厂生成的是产品族，一个工厂可以生成多种类别的组件，根据组件的高质量 或 廉价 两种属性确定对应的工厂。&lt;/p&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="https://heiku.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Factory method pattern</title>
    <link href="https://heiku.github.io/2018/07/27/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/"/>
    <id>https://heiku.github.io/2018/07/27/工厂方法模式/</id>
    <published>2018-07-27T03:24:18.000Z</published>
    <updated>2019-09-19T10:10:55.461Z</updated>
    
    <content type="html"><![CDATA[<p><strong>概念</strong></p><p>定义一个创建对象的接口，但让实现这个接口的类来决定实例化哪个类。工厂方法让类的实例化推迟到子类中进行。</p><p><strong>举例</strong></p><p>使用了工厂方法模式，最大的优点就是当我们需要一个类对象时，只需要通过将我们需要的条件告诉具体的实现工厂，工厂就会返回给我们需要的对象，将对象封装在工厂中。同时，当具体产品类型增加时，我们只需定义该类，并告诉工厂我们想要该类对象，工厂就会自动帮我们创建。</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Created by Heiku on 2018/7/27</span><br><span class="line"> */</span><br><span class="line">// 手机组件</span><br><span class="line">abstract class PhoneComponents&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 摄像头</span><br><span class="line">class CameraComponent extends PhoneComponents&#123;</span><br><span class="line"></span><br><span class="line">    CameraComponent()&#123;</span><br><span class="line">        System.out.println(&quot;get cameraComponent&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 屏幕</span><br><span class="line">class ScreenComponent extends PhoneComponents&#123;</span><br><span class="line"></span><br><span class="line">    ScreenComponent()&#123;</span><br><span class="line">        System.out.println(&quot;get screenComponent&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 处理器</span><br><span class="line">class ProcessorComponent extends PhoneComponents&#123;</span><br><span class="line"></span><br><span class="line">    ProcessorComponent()&#123;</span><br><span class="line">        System.out.println(&quot;get prodcessorComponent&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 工厂接口</span><br><span class="line">interface Factory&#123;</span><br><span class="line"></span><br><span class="line">    &lt;T extends PhoneComponents&gt; T createComponent(Class&lt;T&gt; clazz);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 实际工厂</span><br><span class="line">class ComponentFactory implements Factory&#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public &lt;T extends PhoneComponents&gt; T createComponent(Class&lt;T&gt; clazz) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            return clazz.newInstance();</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 手机零件店</span><br><span class="line">public class PhoneShop &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        Factory factory = new ComponentFactory();</span><br><span class="line"></span><br><span class="line">        // 我需要摄像头组件</span><br><span class="line">        factory.createComponent(CameraComponent.class);</span><br><span class="line"></span><br><span class="line">        // 我需要屏幕组件</span><br><span class="line">        factory.createComponent(ScreenComponent.class);</span><br><span class="line"></span><br><span class="line">        // 我需要处理器组件</span><br><span class="line">        factory.createComponent(ProcessorComponent.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;概念&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;定义一个创建对象的接口，但让实现这个接口的类来决定实例化哪个类。工厂方法让类的实例化推迟到子类中进行。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;举例&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用了工厂方法模式，最大的优点就是当我们需要一个类对象时，只需要通过将我们需要的条件告诉具体的实现工厂，工厂就会返回给我们需要的对象，将对象封装在工厂中。同时，当具体产品类型增加时，我们只需定义该类，并告诉工厂我们想要该类对象，工厂就会自动帮我们创建。&lt;/p&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="https://heiku.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>LinkedHashMap-源码分析</title>
    <link href="https://heiku.github.io/2018/07/24/LinkedHashMap-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>https://heiku.github.io/2018/07/24/LinkedHashMap-源码分析/</id>
    <published>2018-07-24T03:08:09.000Z</published>
    <updated>2018-07-24T04:03:09.380Z</updated>
    
    <content type="html"><![CDATA[<p><strong>数据结构</strong></p><p>LinkedHashMap 继承了HashMap,对HashMap进行了增强，通过内部维护了双向链表，使LinkedHashMap拥有了顺序访问的功能，提供了有序性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public class LinkedHashMap&lt;K,V&gt;</span><br><span class="line">    extends HashMap&lt;K,V&gt;</span><br><span class="line">    implements Map&lt;K,V&gt;</span><br></pre></td></tr></table></figure><p><strong>内部构造</strong></p><p>Entry内部维护了 before 和 after 两个entry，用于构建双向链表entry之间的指向关系，同时accessOrder 用于设置LinkedHashMap的读取是按照访问顺序还是插入顺序，通过这个accessOrder属性可以很容易实现 LRU<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">static class Entry&lt;K,V&gt; extends HashMap.Node&lt;K,V&gt; &#123;</span><br><span class="line">    Entry&lt;K,V&gt; before, after;</span><br><span class="line">    Entry(int hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        super(hash, key, value, next);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 头节点（最旧未使用）</span><br><span class="line">transient LinkedHashMap.Entry&lt;K,V&gt; head;</span><br><span class="line"></span><br><span class="line">// 尾节点 （最近使用）</span><br><span class="line">transient LinkedHashMap.Entry&lt;K,V&gt; tail;</span><br><span class="line"></span><br><span class="line">// 设置LinkedHashMap的读取顺序</span><br><span class="line">//      false(default)：插入顺序</span><br><span class="line">//      true：访问顺序</span><br><span class="line">final boolean accessOrder;</span><br></pre></td></tr></table></figure></p><a id="more"></a><p><strong>get(Object key)</strong></p><p>get()方法使用的是HashMap的get(),但如果 accessOrder 为 true时，要根据最近访问的原则，将访问到的元素添加到LinkedHashMap末尾</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> public V get(Object key) &#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    if ((e = getNode(hash(key), key)) == null)</span><br><span class="line">        return null;</span><br><span class="line">    if (accessOrder)</span><br><span class="line">        afterNodeAccess(e);</span><br><span class="line">    return e.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体的移动节点到末尾的代码，同时要考虑到节点临界值的问题（-双向链接， -&gt; 单向链接）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">void afterNodeAccess(Node&lt;K,V&gt; e) &#123; // move node to last</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; last;</span><br><span class="line"></span><br><span class="line">    // 如果 accessOrder为true，并且当前节点不是tail节点（尾节点不用移动位置），进行移动操作</span><br><span class="line">    if (accessOrder &amp;&amp; (last = tail) != e) &#123;</span><br><span class="line"></span><br><span class="line">        // 获取当前节点的 b(before) a(after)</span><br><span class="line">        // b - p - a</span><br><span class="line">        LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">            (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;</span><br><span class="line"></span><br><span class="line">        // 当前节点的after释放</span><br><span class="line">        p.after = null;</span><br><span class="line"></span><br><span class="line">        // 如果b为空，即当前节点p为head</span><br><span class="line">        if (b == null)</span><br><span class="line">            head = a;</span><br><span class="line"></span><br><span class="line">        // b -&gt; a</span><br><span class="line">        else</span><br><span class="line">            b.after = a;</span><br><span class="line"></span><br><span class="line">        // a不为空，b &lt;- a</span><br><span class="line">        if (a != null)</span><br><span class="line">            a.before = b;</span><br><span class="line"></span><br><span class="line">        // a空，b为tail节点</span><br><span class="line">        else</span><br><span class="line">            last = b;</span><br><span class="line"></span><br><span class="line">        // 尾节点为空，p设置为头节点</span><br><span class="line">        if (last == null)</span><br><span class="line">            head = p;</span><br><span class="line"></span><br><span class="line">        // 将p放入链表末尾 last -&gt; p</span><br><span class="line">        else &#123;</span><br><span class="line">            p.before = last;</span><br><span class="line">            last.after = p;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 刷新设置尾节点p</span><br><span class="line">        tail = p;</span><br><span class="line">        ++modCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>put(Object K, Object V)</strong></p><p>LinkedHashMap内部并没有put()，它采用的是HashMap中的put()，同时根据访问规则，将新节点放入队列尾部</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">final V putVal(int hash, K key, V value, boolean onlyIfAbsent,</span><br><span class="line">               boolean evict) &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;</span><br><span class="line">    if ((tab = table) == null || (n = tab.length) == 0)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    if ((p = tab[i = (n - 1) &amp; hash]) == null)</span><br><span class="line">        tab[i] = newNode(hash, key, value, null);</span><br><span class="line">    else &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        if (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        else if (p instanceof TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);</span><br><span class="line">        else &#123;</span><br><span class="line">            for (int binCount = 0; ; ++binCount) &#123;</span><br><span class="line">                if ((e = p.next) == null) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, null);</span><br><span class="line">                    if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st</span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                if (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">                    break;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (e != null) &#123; // existing mapping for key</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            if (!onlyIfAbsent || oldValue == null)</span><br><span class="line">                e.value = value;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            // 直接回调LinkedHashMap中的具体方法 </span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line"></span><br><span class="line">            return oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    if (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;数据结构&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;LinkedHashMap 继承了HashMap,对HashMap进行了增强，通过内部维护了双向链表，使LinkedHashMap拥有了顺序访问的功能，提供了有序性。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;public class LinkedHashMap&amp;lt;K,V&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    extends HashMap&amp;lt;K,V&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    implements Map&amp;lt;K,V&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;内部构造&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Entry内部维护了 before 和 after 两个entry，用于构建双向链表entry之间的指向关系，同时accessOrder 用于设置LinkedHashMap的读取是按照访问顺序还是插入顺序，通过这个accessOrder属性可以很容易实现 LRU&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;static class Entry&amp;lt;K,V&amp;gt; extends HashMap.Node&amp;lt;K,V&amp;gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Entry&amp;lt;K,V&amp;gt; before, after;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Entry(int hash, K key, V value, Node&amp;lt;K,V&amp;gt; next) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        super(hash, key, value, next);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 头节点（最旧未使用）&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;transient LinkedHashMap.Entry&amp;lt;K,V&amp;gt; head;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 尾节点 （最近使用）&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;transient LinkedHashMap.Entry&amp;lt;K,V&amp;gt; tail;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 设置LinkedHashMap的读取顺序&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//      false(default)：插入顺序&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//      true：访问顺序&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;final boolean accessOrder;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://heiku.github.io/tags/Java/"/>
    
      <category term="LinkedHashMap" scheme="https://heiku.github.io/tags/LinkedHashMap/"/>
    
      <category term="源码分析" scheme="https://heiku.github.io/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>ConcurrentHashMap-源码分析</title>
    <link href="https://heiku.github.io/2018/07/22/ConcurrentHashMap-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>https://heiku.github.io/2018/07/22/ConcurrentHashMap-源码分析/</id>
    <published>2018-07-22T15:29:04.000Z</published>
    <updated>2018-07-23T06:27:43.572Z</updated>
    
    <content type="html"><![CDATA[<p><strong>产生原因</strong></p><ul><li>在多线程环境下，HashMap在扩容时会产生死循环，而线程安全的HashTable，在涉及多线程的操作都采用Synchronized锁住整个数组表，即所有线程在争夺一个资源，效率很低。</li></ul><p><strong>1.7 vs 1.8</strong></p><ul><li>1.7的 ConcurrentHashMap 采用的是分段锁的设计，底层数据结构是Segment + HashEntry，Segment实现了ReentrantLock，自带锁的功能，每次只锁定对应的Segment，多个线程争夺同个segment时，通过tryLock争夺，锁定的粒度下降了，性能也就提高了不少。</li></ul><ul><li>1.8的ConcurrentHashMap 摒弃了分段锁的概念（Segment），沿用了HashMap的思想，基于数组 + 链表 + 红黑树，底层采用的Node + CAS + Synchronized，保证并发的安全性，锁住的是粒度更小的Node。</li></ul><p><strong>分析</strong></p><p>内部类Node, 实现了Map.Entry，用于存储<k,v>键值对，节点用 volatile修饰，保证了多线程间的可见性，同时注意 value也用volatile修饰，无法通过setValue设置value变量。</k,v></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;</span><br><span class="line">    final int hash;</span><br><span class="line">    final K key;</span><br><span class="line">    volatile V val;</span><br><span class="line">    volatile Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">    Node(int hash, K key, V val, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        this.hash = hash;</span><br><span class="line">        this.key = key;</span><br><span class="line">        this.val = val;</span><br><span class="line">        this.next = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public final K getKey()       &#123; return key; &#125;</span><br><span class="line">    public final V getValue()     &#123; return val; &#125;</span><br><span class="line">    public final int hashCode()   &#123; return key.hashCode() ^ val.hashCode(); &#125;</span><br><span class="line">    public final String toString()&#123; return key + &quot;=&quot; + val; &#125;</span><br><span class="line">    public final V setValue(V value) &#123;</span><br><span class="line">        throw new UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public final boolean equals(Object o) &#123;</span><br><span class="line">        Object k, v, u; Map.Entry&lt;?,?&gt; e;</span><br><span class="line">        return ((o instanceof Map.Entry) &amp;&amp;</span><br><span class="line">                (k = (e = (Map.Entry&lt;?,?&gt;)o).getKey()) != null &amp;&amp;</span><br><span class="line">                (v = e.getValue()) != null &amp;&amp;</span><br><span class="line">                (k == key || k.equals(key)) &amp;&amp;</span><br><span class="line">                (v == (u = val) || v.equals(u)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Virtualized support for map.get(); overridden in subclasses.</span><br><span class="line">     */</span><br><span class="line">    Node&lt;K,V&gt; find(int h, Object k) &#123;</span><br><span class="line">        Node&lt;K,V&gt; e = this;</span><br><span class="line">        if (k != null) &#123;</span><br><span class="line">            do &#123;</span><br><span class="line">                K ek;</span><br><span class="line">                if (e.hash == h &amp;&amp;</span><br><span class="line">                    ((ek = e.key) == k || (ek != null &amp;&amp; k.equals(ek))))</span><br><span class="line">                    return e;</span><br><span class="line">            &#125; while ((e = e.next) != null);</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a> <p><strong>属性值</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// Node数组，数组大小会被调整到2的整数次幂，同时用volatile修饰</span><br><span class="line">transient volatile Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 基本计数器，CAS更新</span><br><span class="line">private transient volatile long baseCount;</span><br><span class="line"></span><br><span class="line">// 表示表初始化或扩容时的标识符</span><br><span class="line">// 主要有一下几种状态：</span><br><span class="line">        -1：初始化</span><br><span class="line">        -n：有n-1个线程进行扩容操作</span><br><span class="line">        0|n：hash尚未初始化，标识下次扩容的大小</span><br><span class="line">private transient volatile int sizeCtl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">private transient volatile int transferIndex;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">private transient volatile int cellsBusy;</span><br><span class="line"></span><br><span class="line">private transient volatile CounterCell[] counterCells;</span><br></pre></td></tr></table></figure><p><strong>取hash值</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 与HashMap差不多，前16位与后16位进行异或操作，结果值要 &amp; HASH_BITS,</span><br><span class="line">//这个 HASH_BITS代表的是Integer.MAX_VALUE,目的是消除 hash最高位的负号，因为符号在ConcurrentHashMap有特别的意义，代表不同的节点</span><br><span class="line">static final int spread(int h) &#123;</span><br><span class="line">    return (h ^ (h &gt;&gt;&gt; 16)) &amp; HASH_BITS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static final int HASH_BITS = 0x7fffffff;</span><br><span class="line"></span><br><span class="line"> // 记录hash值的不同状态（forwarding节点、TreeBin节点）</span><br><span class="line">static final int MOVED     = -1; // hash for forwarding nodes</span><br><span class="line">static final int TREEBIN   = -2; // hash for roots of trees</span><br><span class="line">static final int RESERVED  = -3; // hash for transient reservations</span><br><span class="line">static final int HASH_BITS = 0x7fffffff; // usable bits of normal node hash</span><br></pre></td></tr></table></figure><p><strong>put()</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">    return putVal(key, value, false);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/** Implementation for put and putIfAbsent */</span><br><span class="line">final V putVal(K key, V value, boolean onlyIfAbsent) &#123;</span><br><span class="line"></span><br><span class="line">    // key值不允许为null，否则抛出异常</span><br><span class="line">    if (key == null || value == null) throw new NullPointerException();</span><br><span class="line"></span><br><span class="line">    // 取hash值</span><br><span class="line">    int hash = spread(key.hashCode());</span><br><span class="line">    int binCount = 0;</span><br><span class="line"></span><br><span class="line">    // 循环添加</span><br><span class="line">    for (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; int n, i, fh;</span><br><span class="line"></span><br><span class="line">        // table为null，则进行初始化</span><br><span class="line">        if (tab == null || (n = tab.length) == 0)</span><br><span class="line">            tab = initTable();</span><br><span class="line"></span><br><span class="line">        // 通过 hash &amp; length - 1，得到对应的位置，如果位置为空，直接CAS放入</span><br><span class="line">        else if ((f = tabAt(tab, i = (n - 1) &amp; hash)) == null) &#123;</span><br><span class="line">            if (casTabAt(tab, i, null,</span><br><span class="line">                         new Node&lt;K,V&gt;(hash, key, value, null)))</span><br><span class="line">                break;                   // no lock when adding to empty bin</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // forward节点处于 MOVE 状态（扩容），当前线程加入到扩容操作中</span><br><span class="line">        else if ((fh = f.hash) == MOVED)</span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line"></span><br><span class="line">        // 插入节点非null，且不处于扩容状态，synchronized同步添加，判断是否是链表还是树</span><br><span class="line">        else &#123;</span><br><span class="line">            V oldVal = null;</span><br><span class="line"></span><br><span class="line">            synchronized (f) &#123;</span><br><span class="line"></span><br><span class="line">                // 对应的数组下标已经有了元素</span><br><span class="line">                if (tabAt(tab, i) == f) &#123;</span><br><span class="line"></span><br><span class="line">                    // fh &gt;= 0，说明是链表，遍历节点，添加值或替换值</span><br><span class="line">                    if (fh &gt;= 0) &#123;</span><br><span class="line">                        binCount = 1;</span><br><span class="line">                        for (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                            K ek;</span><br><span class="line"></span><br><span class="line">                            // 替换</span><br><span class="line">                            if (e.hash == hash &amp;&amp;</span><br><span class="line">                                ((ek = e.key) == key ||</span><br><span class="line">                                 (ek != null &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                oldVal = e.val;</span><br><span class="line">                                if (!onlyIfAbsent)</span><br><span class="line">                                    e.val = value;</span><br><span class="line">                                break;</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            // 尾节点添加</span><br><span class="line">                            Node&lt;K,V&gt; pred = e;</span><br><span class="line">                            if ((e = e.next) == null) &#123;</span><br><span class="line">                                pred.next = new Node&lt;K,V&gt;(hash, key,</span><br><span class="line">                                                          value, null);</span><br><span class="line">                                break;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    // 树节点，采用红黑树添加</span><br><span class="line">                    else if (f instanceof TreeBin) &#123;</span><br><span class="line">                        Node&lt;K,V&gt; p;</span><br><span class="line">                        binCount = 2;</span><br><span class="line">                        if ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                                       value)) != null) &#123;</span><br><span class="line">                            oldVal = p.val;</span><br><span class="line">                            if (!onlyIfAbsent)</span><br><span class="line">                                p.val = value;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (binCount != 0) &#123;</span><br><span class="line"></span><br><span class="line">                // 判断链表长度是否到达8，转化为红黑树</span><br><span class="line">                if (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                    treeifyBin(tab, i);</span><br><span class="line">                if (oldVal != null)</span><br><span class="line">                    return oldVal;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 更新ConcurrentHashMap的数量，+1</span><br><span class="line">    addCount(1L, binCount);</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>get(Object key)</strong></p><p>对于get（Object key）相对简单，只要匹配对应的key,hash，就可以获取相应的value</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public V get(Object key) &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; int n, eh; K ek;</span><br><span class="line"></span><br><span class="line">    // 取得hash值</span><br><span class="line">    int h = spread(key.hashCode());</span><br><span class="line">    if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;</span><br><span class="line">        (e = tabAt(tab, (n - 1) &amp; h)) != null) &#123;</span><br><span class="line"></span><br><span class="line">        // key和hash匹配，直接返回对用节点</span><br><span class="line">        if ((eh = e.hash) == h) &#123;</span><br><span class="line">            if ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek)))</span><br><span class="line">                return e.val;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // eh &lt; 0,非正常节点（扩容或树节点），采用 内部类的ForwardingNode 和 TreeNode的find()</span><br><span class="line">        else if (eh &lt; 0)</span><br><span class="line">            return (p = e.find(h, key)) != null ? p.val : null;</span><br><span class="line"></span><br><span class="line">        // 正常节点，直接链表递归查找</span><br><span class="line">        while ((e = e.next) != null) &#123;</span><br><span class="line">            if (e.hash == h &amp;&amp;</span><br><span class="line">                ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek))))</span><br><span class="line">                return e.val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>initTable()</strong></p><p>初始化table，初始化操作依赖于sizeCtl变量，通过这个变量判断其他线程是否在执行，否则线程自己进行初始化</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">private final Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; int sc;</span><br><span class="line"></span><br><span class="line">    // 循环创建table，保证一定创建成功</span><br><span class="line">    while ((tab = table) == null || tab.length == 0) &#123;</span><br><span class="line"></span><br><span class="line">        // 根据sizeCtl变量判断其他线程是否在执行初始化，如果是，将自己线程挂起，保证只有一个线程进行初始化</span><br><span class="line">        if ((sc = sizeCtl) &lt; 0)</span><br><span class="line">            Thread.yield(); // lost initialization race; just spin</span><br><span class="line"></span><br><span class="line">        // 只有自己线程在进行初始化，那么CAS将sizeCtl设置为-1，表示当前线程在进行初始化</span><br><span class="line">        else if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                if ((tab = table) == null || tab.length == 0) &#123;</span><br><span class="line">                    int n = (sc &gt; 0) ? sc : DEFAULT_CAPACITY;</span><br><span class="line">                    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n];</span><br><span class="line">                    table = tab = nt;</span><br><span class="line">                    sc = n - (n &gt;&gt;&gt; 2);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                sizeCtl = sc;</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return tab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>transfer()</strong></p><p>扩容操作主要分为两部分：<br>    （1）创建一个nextTable数组，容量为原来的两倍，单线程完成<br>    （2）将原table数组的元素按规则复制到nextTable，多线程处理</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br></pre></td><td class="code"><pre><span class="line">// 创建新数组</span><br><span class="line">private transient volatile Node&lt;K,V&gt;[] nextTable;</span><br><span class="line"></span><br><span class="line">private final void transfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab) &#123;</span><br><span class="line">    int n = tab.length, stride;</span><br><span class="line"></span><br><span class="line">    // 根据cpu个数找出扩容时的数组跨度大小 16,32,64</span><br><span class="line">    if ((stride = (NCPU &gt; 1) ? (n &gt;&gt;&gt; 3) / NCPU : n) &lt; MIN_TRANSFER_STRIDE)</span><br><span class="line">        stride = MIN_TRANSFER_STRIDE; // subdivide range</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    // 正式初始化</span><br><span class="line">    // 新创建nextTable，容量为原来的两倍</span><br><span class="line">    if (nextTab == null) &#123;            // initiating</span><br><span class="line">        try &#123;</span><br><span class="line">            @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">            Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n &lt;&lt; 1];</span><br><span class="line">            nextTab = nt;</span><br><span class="line">        &#125; catch (Throwable ex) &#123;      // try to cope with OOME</span><br><span class="line">            sizeCtl = Integer.MAX_VALUE;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        nextTable = nextTab;</span><br><span class="line"></span><br><span class="line">        //旧数组开始的转移位置，逆序迁移</span><br><span class="line">        transferIndex = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 创建扩容连接节点，将nextTable[]放入</span><br><span class="line">    int nextn = nextTab.length;</span><br><span class="line">    ForwardingNode&lt;K,V&gt; fwd = new ForwardingNode&lt;K,V&gt;(nextTab);</span><br><span class="line"></span><br><span class="line">    // 表示节点是否已经处理过</span><br><span class="line">    boolean advance = true;</span><br><span class="line"></span><br><span class="line">    // 扩容是否完成</span><br><span class="line">    boolean finishing = false; // to ensure sweep before committing nextTab</span><br><span class="line"></span><br><span class="line">    // 使用i表示当前处理的槽位，bound表示需要处理的槽位边界</span><br><span class="line">    for (int i = 0, bound = 0;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; int fh;</span><br><span class="line">        while (advance) &#123;</span><br><span class="line">            int nextIndex, nextBound;</span><br><span class="line">            if (--i &gt;= bound || finishing)</span><br><span class="line">                advance = false;</span><br><span class="line"></span><br><span class="line">            // 迁移到头了</span><br><span class="line">            else if ((nextIndex = transferIndex) &lt;= 0) &#123;</span><br><span class="line">                i = -1;</span><br><span class="line">                advance = false;</span><br><span class="line">            &#125;</span><br><span class="line">            // i = 15，bound = 0</span><br><span class="line">            else if (U.compareAndSwapInt</span><br><span class="line">                     (this, TRANSFERINDEX, nextIndex,</span><br><span class="line">                      nextBound = (nextIndex &gt; stride ?</span><br><span class="line">                                   nextIndex - stride : 0))) &#123;</span><br><span class="line">                bound = nextBound;</span><br><span class="line">                i = nextIndex - 1;</span><br><span class="line">                advance = false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 全部迁移</span><br><span class="line">        if (i &lt; 0 || i &gt;= n || i + n &gt;= nextn) &#123;</span><br><span class="line">            int sc;</span><br><span class="line"></span><br><span class="line">            // 扩容完成，将nextTable赋值给table，清空临时表，重新设置sizeCtl</span><br><span class="line">            if (finishing) &#123;</span><br><span class="line">                nextTable = null;</span><br><span class="line">                table = nextTab;</span><br><span class="line">                sizeCtl = (n &lt;&lt; 1) - (n &gt;&gt;&gt; 1);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // CAS修改sizeCtl,sc - 1说明新增加扩容线程</span><br><span class="line">            if (U.compareAndSwapInt(this, SIZECTL, sc = sizeCtl, sc - 1)) &#123;</span><br><span class="line">                if ((sc - 2) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)</span><br><span class="line">                    return;</span><br><span class="line"></span><br><span class="line">                // 完成</span><br><span class="line">                finishing = advance = true;</span><br><span class="line">                i = n; // recheck before commit</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 遍历的节点为空，放入Forwarding node</span><br><span class="line">        else if ((f = tabAt(tab, i)) == null)</span><br><span class="line">            advance = casTabAt(tab, i, null, fwd);</span><br><span class="line"></span><br><span class="line">        // 遍历到的节点为Forwarding node节点，说明被处理过了，直接跳过</span><br><span class="line">        else if ((fh = f.hash) == MOVED)</span><br><span class="line">            advance = true; // already processed</span><br><span class="line"></span><br><span class="line">        else &#123;</span><br><span class="line">            // 锁住节点</span><br><span class="line">            synchronized (f) &#123;</span><br><span class="line">                if (tabAt(tab, i) == f) &#123;</span><br><span class="line"></span><br><span class="line">                    // 构造两个节点，在新数组中保存低位（0）和高位（1）的数组节点</span><br><span class="line">                    Node&lt;K,V&gt; ln, hn;</span><br><span class="line"></span><br><span class="line">                    // fh &gt; 0,Node节点，获取</span><br><span class="line">                    if (fh &gt;= 0) &#123;</span><br><span class="line"></span><br><span class="line">                        // 获取原标志位，用于比较节点是否位于新数组</span><br><span class="line">                        int runBit = fh &amp; n;</span><br><span class="line">                        Node&lt;K,V&gt; lastRun = f;</span><br><span class="line"></span><br><span class="line">                        // 遍历链表判断状态，记录下 runBit 和 lastRun</span><br><span class="line">                        for (Node&lt;K,V&gt; p = f.next; p != null; p = p.next) &#123;</span><br><span class="line">                            int b = p.hash &amp; n;</span><br><span class="line">                            if (b != runBit) &#123;</span><br><span class="line">                                runBit = b;</span><br><span class="line">                                lastRun = p;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        // 这里为两个链表设置头，一个正序，一个倒序</span><br><span class="line">                        if (runBit == 0) &#123;</span><br><span class="line">                            ln = lastRun;</span><br><span class="line">                            hn = null;</span><br><span class="line">                        &#125;</span><br><span class="line">                        else &#123;</span><br><span class="line">                            hn = lastRun;</span><br><span class="line">                            ln = null;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        // 遍历链表，根据标识位构造 ln链表和 hn链表</span><br><span class="line">                        for (Node&lt;K,V&gt; p = f; p != lastRun; p = p.next) &#123;</span><br><span class="line">                            int ph = p.hash; K pk = p.key; V pv = p.val;</span><br><span class="line">                            if ((ph &amp; n) == 0)</span><br><span class="line">                                ln = new Node&lt;K,V&gt;(ph, pk, pv, ln);</span><br><span class="line">                            else</span><br><span class="line">                                hn = new Node&lt;K,V&gt;(ph, pk, pv, hn);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        // 在nextTable的 i 位置插入ln链表</span><br><span class="line">                        setTabAt(nextTab, i, ln);</span><br><span class="line"></span><br><span class="line">                        // 在nextTable的 i+n 位置插入hn链表</span><br><span class="line">                        setTabAt(nextTab, i + n, hn);</span><br><span class="line"></span><br><span class="line">                        // 设置forwarding节点，表示已经处理过了</span><br><span class="line">                        setTabAt(tab, i, fwd);</span><br><span class="line"></span><br><span class="line">                        // 标识advance 为true，i--</span><br><span class="line">                        advance = true;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    // 对树节点进行处理</span><br><span class="line">                    else if (f instanceof TreeBin) &#123;</span><br><span class="line">                        TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f;</span><br><span class="line">                        TreeNode&lt;K,V&gt; lo = null, loTail = null;</span><br><span class="line">                        TreeNode&lt;K,V&gt; hi = null, hiTail = null;</span><br><span class="line">                        int lc = 0, hc = 0;</span><br><span class="line">                        for (Node&lt;K,V&gt; e = t.first; e != null; e = e.next) &#123;</span><br><span class="line">                            int h = e.hash;</span><br><span class="line">                            TreeNode&lt;K,V&gt; p = new TreeNode&lt;K,V&gt;</span><br><span class="line">                                (h, e.key, e.val, null, null);</span><br><span class="line">                            if ((h &amp; n) == 0) &#123;</span><br><span class="line">                                if ((p.prev = loTail) == null)</span><br><span class="line">                                    lo = p;</span><br><span class="line">                                else</span><br><span class="line">                                    loTail.next = p;</span><br><span class="line">                                loTail = p;</span><br><span class="line">                                ++lc;</span><br><span class="line">                            &#125;</span><br><span class="line">                            else &#123;</span><br><span class="line">                                if ((p.prev = hiTail) == null)</span><br><span class="line">                                    hi = p;</span><br><span class="line">                                else</span><br><span class="line">                                    hiTail.next = p;</span><br><span class="line">                                hiTail = p;</span><br><span class="line">                                ++hc;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        ln = (lc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(lo) :</span><br><span class="line">                            (hc != 0) ? new TreeBin&lt;K,V&gt;(lo) : t;</span><br><span class="line">                        hn = (hc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(hi) :</span><br><span class="line">                            (lc != 0) ? new TreeBin&lt;K,V&gt;(hi) : t;</span><br><span class="line">                        setTabAt(nextTab, i, ln);</span><br><span class="line">                        setTabAt(nextTab, i + n, hn);</span><br><span class="line">                        setTabAt(tab, i, fwd);</span><br><span class="line">                        advance = true;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;产生原因&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在多线程环境下，HashMap在扩容时会产生死循环，而线程安全的HashTable，在涉及多线程的操作都采用Synchronized锁住整个数组表，即所有线程在争夺一个资源，效率很低。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;1.7 vs 1.8&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1.7的 ConcurrentHashMap 采用的是分段锁的设计，底层数据结构是Segment + HashEntry，Segment实现了ReentrantLock，自带锁的功能，每次只锁定对应的Segment，多个线程争夺同个segment时，通过tryLock争夺，锁定的粒度下降了，性能也就提高了不少。&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;1.8的ConcurrentHashMap 摒弃了分段锁的概念（Segment），沿用了HashMap的思想，基于数组 + 链表 + 红黑树，底层采用的Node + CAS + Synchronized，保证并发的安全性，锁住的是粒度更小的Node。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;分析&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;内部类Node, 实现了Map.Entry，用于存储&lt;k,v&gt;键值对，节点用 volatile修饰，保证了多线程间的可见性，同时注意 value也用volatile修饰，无法通过setValue设置value变量。&lt;/k,v&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;static class Node&amp;lt;K,V&amp;gt; implements Map.Entry&amp;lt;K,V&amp;gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    final int hash;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    final K key;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    volatile V val;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    volatile Node&amp;lt;K,V&amp;gt; next;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Node(int hash, K key, V val, Node&amp;lt;K,V&amp;gt; next) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        this.hash = hash;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        this.key = key;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        this.val = val;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        this.next = next;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    public final K getKey()       &amp;#123; return key; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    public final V getValue()     &amp;#123; return val; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    public final int hashCode()   &amp;#123; return key.hashCode() ^ val.hashCode(); &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    public final String toString()&amp;#123; return key + &amp;quot;=&amp;quot; + val; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    public final V setValue(V value) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        throw new UnsupportedOperationException();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    public final boolean equals(Object o) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Object k, v, u; Map.Entry&amp;lt;?,?&amp;gt; e;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return ((o instanceof Map.Entry) &amp;amp;&amp;amp;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                (k = (e = (Map.Entry&amp;lt;?,?&amp;gt;)o).getKey()) != null &amp;amp;&amp;amp;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                (v = e.getValue()) != null &amp;amp;&amp;amp;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                (k == key || k.equals(key)) &amp;amp;&amp;amp;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                (v == (u = val) || v.equals(u)));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    /**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     * Virtualized support for map.get(); overridden in subclasses.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Node&amp;lt;K,V&amp;gt; find(int h, Object k) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Node&amp;lt;K,V&amp;gt; e = this;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        if (k != null) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            do &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                K ek;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                if (e.hash == h &amp;amp;&amp;amp;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    ((ek = e.key) == k || (ek != null &amp;amp;&amp;amp; k.equals(ek))))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    return e;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125; while ((e = e.next) != null);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return null;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://heiku.github.io/tags/Java/"/>
    
      <category term="源码分析" scheme="https://heiku.github.io/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
      <category term="ConcurrentHashMap" scheme="https://heiku.github.io/tags/ConcurrentHashMap/"/>
    
  </entry>
  
  <entry>
    <title>使用位运算替代+-运算符</title>
    <link href="https://heiku.github.io/2018/05/21/%E4%BD%BF%E7%94%A8%E4%BD%8D%E8%BF%90%E7%AE%97%E6%9B%BF%E4%BB%A3-%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
    <id>https://heiku.github.io/2018/05/21/使用位运算替代-运算符/</id>
    <published>2018-05-21T07:56:13.000Z</published>
    <updated>2019-09-19T10:11:20.564Z</updated>
    
    <content type="html"><![CDATA[<h4 id="最近在刷-LeetCode-时，看到一道关于位运算的算法题"><a href="#最近在刷-LeetCode-时，看到一道关于位运算的算法题" class="headerlink" title="最近在刷 LeetCode 时，看到一道关于位运算的算法题"></a>最近在刷 LeetCode 时，看到一道关于位运算的算法题</h4><p><a href="https://leetcode-cn.com/problems/sum-of-two-integers" target="_blank" rel="noopener">不使用运算符 + 和-，计算两整数a 、b之和</a> 归根到底，就是运用计算机底层原理，通过位运算进行运算。</p><p><strong>加法</strong><br>思路：用异运算构造两个数的和（不包含进位），用与运算再左移构造两者和的进位数，通过递归直到不进位。</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public int getSum(int a, int b) &#123;</span><br><span class="line">        if (b == 0)&#123;</span><br><span class="line">            return a;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int sum = a ^ b;</span><br><span class="line">        int carry = (a &amp; b) &lt;&lt; 1;</span><br><span class="line"></span><br><span class="line">        return getSum(sum, carry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>减法</strong><br>思路：加上另一个数的补码（取反加一）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int substract(int num1, int num2)&#123;</span><br><span class="line">        int subtractor = getSum(~num2, 1);// 先求减数的补码（取反加一）</span><br><span class="line">        int result = getSum(num1, subtractor); // getSum()即上述加法运算　　</span><br><span class="line">        return result ;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p><strong>乘法</strong><br>思路：先判断两个数是否是正数，取绝对值进行多次加法<br>     或 采用手动乘积的过程，判断乘数的末位，若为1，则相加被乘数。同时，在每次运算的时候，被乘数左移，乘数右移<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">int multiply(int a, int b) &#123;</span><br><span class="line">        int multiplicand = a &lt; 0 ? getSum(~a, 1) : a;</span><br><span class="line">        int multiplier = b &lt; 0 ? getSum(~b , 1) : b;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        //计算绝对值的乘积　　</span><br><span class="line">        int product = 0;</span><br><span class="line">        while(multiplier &gt; 0) &#123;</span><br><span class="line">            if((multiplier &amp; 0x1) &gt; 0) &#123;// 每次考察乘数的最后一位　　　　</span><br><span class="line">                product = getSum(product, multiplicand);</span><br><span class="line">            &#125;</span><br><span class="line">            multiplicand = multiplicand &lt;&lt; 1;// 每运算一次，被乘数要左移一位　　　　</span><br><span class="line">            multiplier = multiplier &gt;&gt; 1;// 每运算一次，乘数要右移一位（可对照上图理解）　　</span><br><span class="line">        &#125;</span><br><span class="line">        //计算乘积的符号　　</span><br><span class="line">        if((a ^ b) &lt; 0) &#123;</span><br><span class="line">            product = getSum(~product, 1);</span><br><span class="line">        &#125;</span><br><span class="line">        return product;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p><strong>除法</strong><br>思路：除数不停减去被除数，直到被除数小于除数，期间减去的次数就是商，剩下的就是余数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">int divide(int a, int b)&#123;</span><br><span class="line">        // 先取被除数和除数的绝对值    </span><br><span class="line">        int dividend = a &gt; 0 ? a : getSum(~a, 1);</span><br><span class="line">        int divisor = b &gt; 0 ? a : getSum(~b, 1);</span><br><span class="line"></span><br><span class="line">        int quotient = 0;// 商    </span><br><span class="line">        int remainder = 0;// 余数    </span><br><span class="line">        // 不断用除数去减被除数，直到被除数小于被除数（即除不尽了）    </span><br><span class="line">        while(dividend &gt;= divisor)&#123;// 直到商小于被除数        </span><br><span class="line">            quotient = getSum(quotient, 1);</span><br><span class="line">            dividend = substract(dividend, divisor);</span><br><span class="line">        &#125;</span><br><span class="line">        // 确定商的符号    </span><br><span class="line">        if((a ^ b) &lt; 0)&#123;// 如果除数和被除数异号，则商为负数  </span><br><span class="line">            quotient = getSum(~quotient, 1);</span><br><span class="line">        &#125;</span><br><span class="line">        // 确定余数符号    </span><br><span class="line">        remainder = b &gt; 0 ? dividend : getSum(~dividend, 1);</span><br><span class="line">        return quotient;// 返回商</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;最近在刷-LeetCode-时，看到一道关于位运算的算法题&quot;&gt;&lt;a href=&quot;#最近在刷-LeetCode-时，看到一道关于位运算的算法题&quot; class=&quot;headerlink&quot; title=&quot;最近在刷 LeetCode 时，看到一道关于位运算的算法题&quot;&gt;&lt;/a&gt;最近在刷 LeetCode 时，看到一道关于位运算的算法题&lt;/h4&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/sum-of-two-integers&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;不使用运算符 + 和-，计算两整数a 、b之和&lt;/a&gt; 归根到底，就是运用计算机底层原理，通过位运算进行运算。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;加法&lt;/strong&gt;&lt;br&gt;思路：用异运算构造两个数的和（不包含进位），用与运算再左移构造两者和的进位数，通过递归直到不进位。&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="https://heiku.github.io/tags/LeetCode/"/>
    
      <category term="算法" scheme="https://heiku.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>HashMap 源码分析</title>
    <link href="https://heiku.github.io/2018/04/21/HashMap-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>https://heiku.github.io/2018/04/21/HashMap-源码分析/</id>
    <published>2018-04-21T12:51:58.000Z</published>
    <updated>2018-07-22T15:30:25.040Z</updated>
    
    <content type="html"><![CDATA[<p><strong>特征</strong></p><ul><li>根据键的 <strong>hascode</strong> 值存储数据，可直接定位值，具有很快的数据访问数组</li><li>遍历的顺序不确定</li><li>最多允许一条 null 键，允许多条记录的键为 null</li><li>非线程安全<br>  可使用 Collections.synchronizedMap 使 HashMap 具有线程安全的能力 或 ConcurrentHashMap</li></ul><p><strong>底层结构</strong></p><p>底层结构采用了数组，而数组的每一个元素都是多个 Node 构成的链表，当数组超过 threshold 时，数组将会扩容。</p><p>数组中的每一个都相当于一个单向链表，key 通过 hash() 后，相同的键值对会加入到链表中，当桶中的数过多时（链表长度 &gt; 8），将会转化为 红黑树，相比与Jdk 1.7， Jdk 1.8 中当链表过长时，链表转化为红黑树，在维护红黑树时，最坏情况下查找的时间复杂度为 O(log n)，比起单链表的 O(1) ~ O(n), 时间复杂度降低了，但所需要维护的空间占用却更多。</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 哈希数组桶，根据 key 的 hashCode 通过 hash() 得到数组下标</span><br><span class="line">transient Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line">// 结构最大数据量，即 Node 的最大值，由 loadFactor(o.75) * length(16) 得到 </span><br><span class="line">int threshold;</span><br><span class="line"></span><br><span class="line">// 负载因子</span><br><span class="line">final float loadFactor;</span><br><span class="line"></span><br><span class="line">// 桶中的 Node 节点</span><br><span class="line">static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;</span><br><span class="line">    final int hash;</span><br><span class="line">    final K key;</span><br><span class="line">    V value;</span><br><span class="line">    Node&lt;K,V&gt; next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>哈希映射 &amp; 表大小</strong></p><p>hash() — 取得 key 的 hashCode 值，依次进行 高位运算，取模运算</p><p>tableSizeFor() — 返回大于参数且最接近 2 的整数幂的数值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *  取得hashCode 的值</span><br><span class="line"> *  右位移 16 位，正好是 32bit 的一半，将高半位和低半位做异或</span><br><span class="line"> *  混合原始哈希码的高位和地位，以此加大随机性</span><br><span class="line">  */  </span><br><span class="line">static final int hash(Object key) &#123;</span><br><span class="line">    int h;</span><br><span class="line">    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 将二进制转化为1，找出最大的 2^n的值</span><br><span class="line">static final int tableSizeFor(int cap) &#123;</span><br><span class="line">    int n = cap - 1;</span><br><span class="line">    n |= n &gt;&gt;&gt; 1;</span><br><span class="line">    n |= n &gt;&gt;&gt; 2;</span><br><span class="line">    n |= n &gt;&gt;&gt; 4;</span><br><span class="line">    n |= n &gt;&gt;&gt; 8;</span><br><span class="line">    n |= n &gt;&gt;&gt; 16;</span><br><span class="line">    return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>扩容</strong></p><p>扩容机制实际上就是使用一个更大的数组去 代替 原来的数组，如果原来的数组中存在红黑树 或 链表，则需要把结构重新调整。<br>对于链表而言， 设计者省略了重新计算新容量下 key 的 hash 值，采用将 hash 值与原容量进行与操作，得到不同的扩展区，两个扩展区分为两条链表。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line">final Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    // 记录oldTab, oldCap, oldThr 等数据</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    int oldCap = (oldTab == null) ? 0 : oldTab.length;</span><br><span class="line">    int oldThr = threshold;</span><br><span class="line">    int newCap, newThr = 0;</span><br><span class="line"></span><br><span class="line">    // 当容量大到不能调整时，采用Integer.MAX_VALUE 作为最大容量 threshold</span><br><span class="line">    // 否则，将采用位运算，将 oldCap 和 oldThr 扩展为原来的两倍</span><br><span class="line">    if (oldCap &gt; 0) &#123;</span><br><span class="line">        if (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            return oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; 1; // double threshold</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 尚未分配空间，初始化</span><br><span class="line">    else if (oldThr &gt; 0) // initial capacity was placed in threshold</span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    else &#123;               // zero initial threshold signifies using defaults</span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    if (newThr == 0) &#123;</span><br><span class="line">        float ft = (float)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (int)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line"></span><br><span class="line">    // 重新分配空间</span><br><span class="line">    @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span><br><span class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    if (oldTab != null) &#123;</span><br><span class="line"></span><br><span class="line">        // 循环遍历桶</span><br><span class="line">        for (int j = 0; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line"></span><br><span class="line">            //首元素赋予 null，便于GC </span><br><span class="line">            if ((e = oldTab[j]) != null) &#123;</span><br><span class="line">                oldTab[j] = null;</span><br><span class="line">                if (e.next == null)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - 1)] = e;</span><br><span class="line"></span><br><span class="line">                // 桶中的结构是 红黑树，采用 split()调整结构</span><br><span class="line">                else if (e instanceof TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);</span><br><span class="line">                </span><br><span class="line">                // 桶中结构为单链表</span><br><span class="line">                // 容量增加了，散列时使用的位扩展了一位，通过新扩展为0 1区分</span><br><span class="line">                else &#123; // preserve order</span><br><span class="line"></span><br><span class="line">                    // 分为两条链表，在尾部插入新节点</span><br><span class="line">                    Node&lt;K,V&gt; loHead = null, loTail = null;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = null, hiTail = null;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    do &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        </span><br><span class="line">                        // 新扩展位为0</span><br><span class="line">                        if ((e.hash &amp; oldCap) == 0) &#123;</span><br><span class="line">                            if (loTail == null)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            else</span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        // 新扩展位为1</span><br><span class="line">                        else &#123;</span><br><span class="line">                            if (hiTail == null)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            else</span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; while ((e = next) != null);</span><br><span class="line"></span><br><span class="line">                    // 将头节点放入数组桶中</span><br><span class="line">                    if (loTail != null) &#123;</span><br><span class="line">                        loTail.next = null;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (hiTail != null) &#123;</span><br><span class="line">                        hiTail.next = null;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>存入</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">    return putVal(hash(key), key, value, false, true);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">final V putVal(int hash, K key, V value, boolean onlyIfAbsent,</span><br><span class="line">               boolean evict) &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;</span><br><span class="line"></span><br><span class="line">    // 判断空桶，resize（）重新建桶</span><br><span class="line">    if ((tab = table) == null || (n = tab.length) == 0)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line"></span><br><span class="line">    // 首节点为null, 新建节点Node</span><br><span class="line">    if ((p = tab[i = (n - 1) &amp; hash]) == null)</span><br><span class="line">        tab[i] = newNode(hash, key, value, null);</span><br><span class="line">    else &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line"></span><br><span class="line">        // 首节点相同，覆盖</span><br><span class="line">        if (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line"></span><br><span class="line">        // 桶中结构为红黑树，调用红黑树的 putTreeVal()</span><br><span class="line">        else if (p instanceof TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);</span><br><span class="line"></span><br><span class="line">        // 桶中结构为链表</span><br><span class="line">        else &#123;</span><br><span class="line">            for (int binCount = 0; ; ++binCount) &#123;</span><br><span class="line">                if ((e = p.next) == null) &#123;</span><br><span class="line"></span><br><span class="line">                    // 以此存入节点，当链表总数大于8时，转化为红黑树</span><br><span class="line">                    p.next = newNode(hash, key, value, null);</span><br><span class="line">                    if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st</span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                //key已在链表中</span><br><span class="line">                if (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">                    break;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 替代旧值，返回旧值</span><br><span class="line">        if (e != null) &#123; // existing mapping for key</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            if (!onlyIfAbsent || oldValue == null)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            return oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 修改计数器加一</span><br><span class="line">    ++modCount;</span><br><span class="line"></span><br><span class="line">    // 当容量大于 threshold， 进行扩容</span><br><span class="line">    if (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>查找</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">// 查找对应key 的值</span><br><span class="line">public V get(Object key) &#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    return (e = getNode(hash(key), key)) == null ? null : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 查找是否存在 key 对应的值</span><br><span class="line">public boolean containsKey(Object key) &#123;</span><br><span class="line">    return getNode(hash(key), key) != null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 查找的具体操作</span><br><span class="line">final Node&lt;K,V&gt; getNode(int hash, Object key) &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k;</span><br><span class="line"></span><br><span class="line">    // table不为空 &amp;&amp; 首节点不为空</span><br><span class="line">    if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;</span><br><span class="line">        (first = tab[(n - 1) &amp; hash]) != null) &#123;</span><br><span class="line"></span><br><span class="line">        // 首节点命中，直接返回</span><br><span class="line">        if (first.hash == hash &amp;&amp; // always check first node</span><br><span class="line">            ((k = first.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">            return first;</span><br><span class="line"></span><br><span class="line">        // 非首节点的情况下</span><br><span class="line">        if ((e = first.next) != null) &#123;</span><br><span class="line"></span><br><span class="line">            // 通过红黑树结构查找，调用 getTreeNode()</span><br><span class="line">            if (first instanceof TreeNode)</span><br><span class="line">                return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line"></span><br><span class="line">            // 链表顺序查找</span><br><span class="line">            do &#123;</span><br><span class="line">                if (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">                    return e;</span><br><span class="line">            &#125; while ((e = e.next) != null);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>删除</strong></p><p>删除的操作与查找差不多，都是要通过key找到对应的节点，再删除节点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">// 删除指定key的值</span><br><span class="line">public V remove(Object key) &#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    return (e = removeNode(hash(key), key, null, false, true)) == null ?</span><br><span class="line">        null : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 删除的具体操作</span><br><span class="line">final Node&lt;K,V&gt; removeNode(int hash, Object key, Object value,</span><br><span class="line">                           boolean matchValue, boolean movable) &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, index;</span><br><span class="line">    if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;</span><br><span class="line">        (p = tab[index = (n - 1) &amp; hash]) != null) &#123;</span><br><span class="line">        Node&lt;K,V&gt; node = null, e; K k; V v;</span><br><span class="line"></span><br><span class="line">        // 首节点命中，赋值node便于删除</span><br><span class="line">        if (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">            node = p;</span><br><span class="line"></span><br><span class="line">        // 首节点未命中</span><br><span class="line">        else if ((e = p.next) != null) &#123;</span><br><span class="line"></span><br><span class="line">            // 红黑树查找</span><br><span class="line">            if (p instanceof TreeNode)</span><br><span class="line">                node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);</span><br><span class="line">            else &#123;</span><br><span class="line"></span><br><span class="line">                // 链表查找</span><br><span class="line">                do &#123;</span><br><span class="line">                    if (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key ||</span><br><span class="line">                         (key != null &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                        node = e;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125; while ((e = e.next) != null);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (node != null &amp;&amp; (!matchValue || (v = node.value) == value ||</span><br><span class="line">                             (value != null &amp;&amp; value.equals(v)))) &#123;</span><br><span class="line">            </span><br><span class="line">            // 红黑树删除，删除同时考虑红黑树的平衡</span><br><span class="line">            if (node instanceof TreeNode)</span><br><span class="line">                ((TreeNode&lt;K,V&gt;)node).removeTreeNode(this, tab, movable);</span><br><span class="line">            </span><br><span class="line">            // 首节点删除，将首节点的next赋值为首节点</span><br><span class="line">            else if (node == p)</span><br><span class="line">                tab[index] = node.next;</span><br><span class="line"></span><br><span class="line">            // 链表删除，节点的next 指向删除节点的 next</span><br><span class="line">            else</span><br><span class="line">                p.next = node.next;</span><br><span class="line"></span><br><span class="line">            // 修改计数， 长度减一， 返回删除节点</span><br><span class="line">            ++modCount;</span><br><span class="line">            --size;</span><br><span class="line">            afterNodeRemoval(node);</span><br><span class="line">            return node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;特征&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;根据键的 &lt;strong&gt;hascode&lt;/strong&gt; 值存储数据，可直接定位值，具有很快的数据访问数组&lt;/li&gt;
&lt;li&gt;遍历的顺序不确定&lt;/li&gt;
&lt;li&gt;最多允许一条 null 键，允许多条记录的键为 null&lt;/li&gt;
&lt;li&gt;非线程安全&lt;br&gt;  可使用 Collections.synchronizedMap 使 HashMap 具有线程安全的能力 或 ConcurrentHashMap&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;底层结构&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;底层结构采用了数组，而数组的每一个元素都是多个 Node 构成的链表，当数组超过 threshold 时，数组将会扩容。&lt;/p&gt;
&lt;p&gt;数组中的每一个都相当于一个单向链表，key 通过 hash() 后，相同的键值对会加入到链表中，当桶中的数过多时（链表长度 &amp;gt; 8），将会转化为 红黑树，相比与Jdk 1.7， Jdk 1.8 中当链表过长时，链表转化为红黑树，在维护红黑树时，最坏情况下查找的时间复杂度为 O(log n)，比起单链表的 O(1) ~ O(n), 时间复杂度降低了，但所需要维护的空间占用却更多。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://heiku.github.io/tags/Java/"/>
    
      <category term="源码分析" scheme="https://heiku.github.io/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
      <category term="HashMap" scheme="https://heiku.github.io/tags/HashMap/"/>
    
  </entry>
  
  <entry>
    <title>ArrayList 源码分析</title>
    <link href="https://heiku.github.io/2018/04/15/ArrayList-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>https://heiku.github.io/2018/04/15/ArrayList-源码分析/</id>
    <published>2018-04-15T02:43:19.000Z</published>
    <updated>2018-07-23T06:32:57.491Z</updated>
    
    <content type="html"><![CDATA[<p>ArrayList 是平时常用的数据存储结构，它基于动态数组，支持随机访问，值得一提的是：<strong>它是不安全的</strong>。造成这种不安全的原因主要是：在在多线程环境下，向 ArrayList 添加或移除时，会产生数组越界等问题。推荐使用 Vector、CopyOnWriteArrayList 代替。</p><h3 id="ArrayList-与-Array-区别："><a href="#ArrayList-与-Array-区别：" class="headerlink" title="ArrayList 与 Array 区别："></a>ArrayList 与 Array 区别：</h3><ul><li>Array 包含的是基本类型和对象类型，而ArrayList 只能包含对象类型</li><li>Array 的大小的是固定的，所以在定义数组的时候尽量确定需要的数组大小，而ArrayList 的大小是动态变化的，当容量不足时能自动扩容</li><li>ArrayList 可以看作Array的增强版，提供了更多的方法和特性，在查找等操作上更方便</li></ul><hr><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;</span><br><span class="line">        implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable</span><br></pre></td></tr></table></figure><a id="more"></a> <p>ArrayList 支持泛型，继承了 AbstractList，在实现了List接口的同时，实现了一下三个接口：</p><ul><li>RandomAccess — 随机访问，即通过元素的序号快速获取对象</li><li>Cloneable    — 覆盖了 clone()，能被克隆</li><li>Serializable — 支持序列化</li></ul><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">private static final long serialVersionUID = 8683452581122892189L;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Default initial capacity.</span><br><span class="line">     */</span><br><span class="line">    private static final int DEFAULT_CAPACITY = 10;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Shared empty array instance used for empty instances.</span><br><span class="line">     */</span><br><span class="line">    private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Shared empty array instance used for default sized empty instances. We</span><br><span class="line">     * distinguish this from EMPTY_ELEMENTDATA to know how much to inflate when</span><br><span class="line">     * first element is added.</span><br><span class="line">     */</span><br><span class="line">    private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * The array buffer into which the elements of the ArrayList are stored.</span><br><span class="line">     * The capacity of the ArrayList is the length of this array buffer. Any</span><br><span class="line">     * empty ArrayList with elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA</span><br><span class="line">     * will be expanded to DEFAULT_CAPACITY when the first element is added.</span><br><span class="line">     */</span><br><span class="line">    transient Object[] elementData; // non-private to simplify nested class access</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * The size of the ArrayList (the number of elements it contains).</span><br><span class="line">     *</span><br><span class="line">     * @serial</span><br><span class="line">     */</span><br><span class="line">    private int size;</span><br></pre></td></tr></table></figure><p>其中，size 指 ArrayList 的大小，DEFAULT_CAPACITY 指在未定义 ArrayList大小的情况下，初始化 elementData 的长度为10<br><strong>elementData</strong> 是 ArrayList 在存储数据时的 buffer，通过数组存储数据。同时，elementData 被 transient 修饰，所以在 ArrayList 序列化的时候，elementData 并不参与，而序列化的过程主要通过 writeObject()，readObject()实现。</p><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 通过传入参数设置 ArrayList的容量</span><br><span class="line"> */</span><br><span class="line">public ArrayList(int initialCapacity) &#123;</span><br><span class="line">    if (initialCapacity &gt; 0) &#123;</span><br><span class="line">        this.elementData = new Object[initialCapacity];</span><br><span class="line">    &#125; else if (initialCapacity == 0) &#123;</span><br><span class="line">        this.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 默认的构造方法，默认容量为10的空数组</span><br><span class="line"> */</span><br><span class="line">public ArrayList() &#123;</span><br><span class="line">    this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 使用集合c 初始化 ArrayList</span><br><span class="line"> */</span><br><span class="line">public ArrayList(Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">    elementData = c.toArray();</span><br><span class="line">    if ((size = elementData.length) != 0) &#123;</span><br><span class="line">        // c.toArray might (incorrectly) not return Object[] (see 6260652)</span><br><span class="line">        if (elementData.getClass() != Object[].class)</span><br><span class="line">            elementData = Arrays.copyOf(elementData, size, Object[].class);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // replace with empty array.</span><br><span class="line">        this.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="具体方法"><a href="#具体方法" class="headerlink" title="具体方法"></a>具体方法</h3><p><strong>查找</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 正序查找</span><br><span class="line"> * 判断查询对象是否为null, 若是则正序查找第一个值为 null 的对象，返回索引号</span><br><span class="line"> */</span><br><span class="line">public int indexOf(Object o) &#123;</span><br><span class="line">    if (o == null) &#123;</span><br><span class="line">        for (int i = 0; i &lt; size; i++)</span><br><span class="line">            if (elementData[i]==null)</span><br><span class="line">                return i;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        for (int i = 0; i &lt; size; i++)</span><br><span class="line">            if (o.equals(elementData[i]))</span><br><span class="line">                return i;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 逆序查找</span><br><span class="line"> * 判断查询对象是否为null, 若是则逆序查找第一个值为 null 的对象，返回索引号</span><br><span class="line"> */</span><br><span class="line">public int lastIndexOf(Object o) &#123;</span><br><span class="line">    if (o == null) &#123;</span><br><span class="line">        for (int i = size-1; i &gt;= 0; i--)</span><br><span class="line">            if (elementData[i]==null)</span><br><span class="line">                return i;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        for (int i = size-1; i &gt;= 0; i--)</span><br><span class="line">            if (o.equals(elementData[i]))</span><br><span class="line">                return i;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><p><strong>拷贝</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 通过super.clone(), 获取 ArrayList 的一个副本，</span><br><span class="line"> * 再设置 ArrayList 的 elementData 和 modCount 属性。因为拷贝的是新的副本，将新副本的 modCount 设为0。</span><br><span class="line"> */</span><br><span class="line">public Object clone() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        ArrayList&lt;?&gt; v = (ArrayList&lt;?&gt;) super.clone();</span><br><span class="line">        v.elementData = Arrays.copyOf(elementData, size);</span><br><span class="line">        v.modCount = 0;</span><br><span class="line">        return v;</span><br><span class="line">    &#125; catch (CloneNotSupportedException e) &#123;</span><br><span class="line">        // this shouldn&apos;t happen, since we are Cloneable</span><br><span class="line">        throw new InternalError(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>在拷贝的过程中，发现它调用了Arrays.copoOf(original, lenght)，而Arrays.copy()又调用了System.arraycopy()</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">public static &lt;T&gt; T[] copyOf(T[] original, int newLength) &#123;</span><br><span class="line">    return (T[]) copyOf(original, newLength, original.getClass());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *  这里的又调用了System.arraycopy()</span><br><span class="line"> */ </span><br><span class="line">public static &lt;T,U&gt; T[] copyOf(U[] original, int newLength, Class&lt;? extends T[]&gt; newType) &#123;</span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    T[] copy = ((Object)newType == (Object)Object[].class)</span><br><span class="line">        ? (T[]) new Object[newLength]</span><br><span class="line">        : (T[]) Array.newInstance(newType.getComponentType(), newLength);</span><br><span class="line">    System.arraycopy(original, 0, copy, 0,</span><br><span class="line">                     Math.min(original.length, newLength));</span><br><span class="line">    return copy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>System.arraycopy()是个 本地方法，底层调用了 c++ 方法实现，使其的效率更高</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static native void arraycopy(Object src,  int  srcPos,</span><br><span class="line">                                        Object dest, int destPos,</span><br><span class="line">                                        int length);</span><br></pre></td></tr></table></figure></p><hr><p><strong>转化为数组</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 返回 elementData 的副本</span><br><span class="line"> */</span><br><span class="line">public Object[] toArray() &#123;</span><br><span class="line">    return Arrays.copyOf(elementData, size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">public &lt;T&gt; T[] toArray(T[] a) &#123;</span><br><span class="line">    if (a.length &lt; size)</span><br><span class="line">        // Make a new array of a&apos;s runtime type, but my contents:</span><br><span class="line">        return (T[]) Arrays.copyOf(elementData, size, a.getClass());</span><br><span class="line">    System.arraycopy(elementData, 0, a, 0, size);</span><br><span class="line">    if (a.length &gt; size)</span><br><span class="line">        a[size] = null;</span><br><span class="line">    return a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><p><strong>获取，修改元素</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 通过索引，返回查询elementData 中的值，便于其他方法的操作</span><br><span class="line"> */</span><br><span class="line">@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">E elementData(int index) &#123;</span><br><span class="line">    return (E) elementData[index];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 数组越界检查</span><br><span class="line">private void rangeCheck(int index) &#123;</span><br><span class="line">    if (index &gt;= size)</span><br><span class="line">        throw new IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *  先进行越界异常检查，判断 index &lt; size 时,返回查询结果</span><br><span class="line"> */</span><br><span class="line">public E get(int index) &#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line"></span><br><span class="line">    return elementData(index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 一样，先进行越界检查，将新值替代为旧值，返回旧值</span><br><span class="line"> */</span><br><span class="line"> public E set(int index, E element) &#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line"></span><br><span class="line">    E oldValue = elementData(index);</span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    return oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><p><strong>移除</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *  通过索引值删除</span><br><span class="line"> *  System.arraycopy()将 elementData 的索引值后的元素向前移动，最后删除最后重复的元素值，size -1</span><br><span class="line"> */</span><br><span class="line">public E remove(int index) &#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line"></span><br><span class="line">    modCount++;</span><br><span class="line">    E oldValue = elementData(index);</span><br><span class="line"></span><br><span class="line">    int numMoved = size - index - 1;</span><br><span class="line">    if (numMoved &gt; 0)</span><br><span class="line">        System.arraycopy(elementData, index+1, elementData, index,</span><br><span class="line">                         numMoved);</span><br><span class="line">    elementData[--size] = null; // clear to let GC do its work</span><br><span class="line"></span><br><span class="line">    return oldValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *  通过对象值删除</span><br><span class="line"> *  正序删除，当查找到要删除的值时，调用 fastRemove() 实现删除的具体操作</span><br><span class="line"> */</span><br><span class="line">public boolean remove(Object o) &#123;</span><br><span class="line">    if (o == null) &#123;</span><br><span class="line">        for (int index = 0; index &lt; size; index++)</span><br><span class="line">            if (elementData[index] == null) &#123;</span><br><span class="line">                fastRemove(index);</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        for (int index = 0; index &lt; size; index++)</span><br><span class="line">            if (o.equals(elementData[index])) &#123;</span><br><span class="line">                fastRemove(index);</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *  fastRemove() 相比于 remove(): 跳过 rangeCheck() 越界检查 和 不返回删除值，这样可以更快得删除元素</span><br><span class="line"> */</span><br><span class="line">private void fastRemove(int index) &#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    int numMoved = size - index - 1;</span><br><span class="line">    if (numMoved &gt; 0)</span><br><span class="line">        System.arraycopy(elementData, index+1, elementData, index,</span><br><span class="line">                         numMoved);</span><br><span class="line">    elementData[--size] = null; // clear to let GC do its work</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><p><strong>清除</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * clear() 并不是将删除整个 elementData,而是清空的意思，所以将所有值赋予null</span><br><span class="line"> */</span><br><span class="line"> public void clear() &#123;</span><br><span class="line">    modCount++;</span><br><span class="line"></span><br><span class="line">    // clear to let GC do its work</span><br><span class="line">    for (int i = 0; i &lt; size; i++)</span><br><span class="line">        elementData[i] = null;</span><br><span class="line"></span><br><span class="line">    size = 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><strong>添加</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *  先容量判断，在数组尾部插入元素</span><br><span class="line"> */</span><br><span class="line">public boolean add(E e) &#123;</span><br><span class="line">    ensureCapacityInternal(size + 1);  // Increments modCount!!</span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *  先越界检查 和 容量判断，将待插入后的元素全部后移，再插入指定元素</span><br><span class="line"> */</span><br><span class="line">public void add(int index, E element) &#123;</span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line"></span><br><span class="line">    ensureCapacityInternal(size + 1);  // Increments modCount!!</span><br><span class="line">    System.arraycopy(elementData, index, elementData, index + 1,</span><br><span class="line">                     size - index);</span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *  和add()方法类似，先将数组后移待插入的集合长度，再插入数组</span><br><span class="line"> */</span><br><span class="line">public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line"></span><br><span class="line">    Object[] a = c.toArray();</span><br><span class="line">    int numNew = a.length;</span><br><span class="line">    ensureCapacityInternal(size + numNew);  // Increments modCount</span><br><span class="line"></span><br><span class="line">    int numMoved = size - index;</span><br><span class="line">    if (numMoved &gt; 0)</span><br><span class="line">        System.arraycopy(elementData, index, elementData, index + numNew,</span><br><span class="line">                         numMoved);</span><br><span class="line"></span><br><span class="line">    System.arraycopy(a, 0, elementData, index, numNew);</span><br><span class="line">    size += numNew;</span><br><span class="line">    return numNew != 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><strong>扩容机制</strong> (扩容机制在jdk 1.7开始做出了改动，主要改动：采用 <a href="https://blog.csdn.net/onezg/article/details/53103559" target="_blank" rel="noopener"><strong>位运算</strong></a> 替代之前的操作符, 加入 <strong>最大数组容量</strong> 的判断)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *  当需要的 容量空间 大于 默认容量，执行ensureExplicitCapacity(minCapacity)</span><br><span class="line"> */</span><br><span class="line">public void ensureCapacity(int minCapacity) &#123;</span><br><span class="line">    int minExpand = (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA)</span><br><span class="line">        // any size if not default element table</span><br><span class="line">        ? 0</span><br><span class="line">        // larger than default for default empty table. It&apos;s already</span><br><span class="line">        // supposed to be at default size.</span><br><span class="line">        : DEFAULT_CAPACITY;</span><br><span class="line"></span><br><span class="line">    if (minCapacity &gt; minExpand) &#123;</span><br><span class="line">        ensureExplicitCapacity(minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void ensureCapacityInternal(int minCapacity) &#123;</span><br><span class="line">    if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ensureExplicitCapacity(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *   modcount+1</span><br><span class="line"> *   需求容量 大于 数组的大小时，执行grow()</span><br><span class="line"> */</span><br><span class="line">private void ensureExplicitCapacity(int minCapacity) &#123;</span><br><span class="line">    modCount++;</span><br><span class="line"></span><br><span class="line">    // overflow-conscious code</span><br><span class="line">    if (minCapacity - elementData.length &gt; 0)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *  扩容的具体方法</span><br><span class="line"> *  oldCapacity + （ oldCapacity &gt;&gt; 1) 位运算向右移一位，使得oldCapacity 为原来的1.5倍</span><br><span class="line"> *  当 newCapacity 大于数组的最大长度时，调用hugeCapacity()调整</span><br><span class="line"> *  拷贝新的 elementData 副本</span><br><span class="line"> */</span><br><span class="line">private void grow(int minCapacity) &#123;</span><br><span class="line">    // overflow-conscious code</span><br><span class="line">    int oldCapacity = elementData.length;</span><br><span class="line">    int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);</span><br><span class="line">    if (newCapacity - minCapacity &lt; 0)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    if (newCapacity - MAX_ARRAY_SIZE &gt; 0)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    // minCapacity is usually close to size, so this is a win:</span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *  调整容量</span><br><span class="line"> */</span><br><span class="line">private static int hugeCapacity(int minCapacity) &#123;</span><br><span class="line">    if (minCapacity &lt; 0) // overflow</span><br><span class="line">        throw new OutOfMemoryError();</span><br><span class="line">    return (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class="line">        Integer.MAX_VALUE :</span><br><span class="line">        MAX_ARRAY_SIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><p><strong>序列化</strong>（序列化的过程是将size, elementData中的所有对象写入或者读取），不采用将整个elementData写入是因为节省空间</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *  首先执行 defaultWriteObject()，目的是将 non-transient 和 non-final 对象写入读取。</span><br><span class="line"> *  写入 size 和 对象</span><br><span class="line"> */</span><br><span class="line">private void writeObject(java.io.ObjectOutputStream s)</span><br><span class="line">    throws java.io.IOException&#123;</span><br><span class="line">    // Write out element count, and any hidden stuff</span><br><span class="line">    int expectedModCount = modCount;</span><br><span class="line">    s.defaultWriteObject();</span><br><span class="line"></span><br><span class="line">    // Write out size as capacity for behavioural compatibility with clone()</span><br><span class="line">    s.writeInt(size);</span><br><span class="line"></span><br><span class="line">    // Write out all elements in the proper order.</span><br><span class="line">    for (int i=0; i&lt;size; i++) &#123;</span><br><span class="line">        s.writeObject(elementData[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (modCount != expectedModCount) &#123;</span><br><span class="line">        throw new ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void readObject(java.io.ObjectInputStream s)</span><br><span class="line">    throws java.io.IOException, ClassNotFoundException &#123;</span><br><span class="line">    elementData = EMPTY_ELEMENTDATA;</span><br><span class="line"></span><br><span class="line">    // Read in size, and any hidden stuff</span><br><span class="line">    s.defaultReadObject();</span><br><span class="line"></span><br><span class="line">    // Read in capacity</span><br><span class="line">    s.readInt(); // ignored</span><br><span class="line"></span><br><span class="line">    if (size &gt; 0) &#123;</span><br><span class="line">        // be like clone(), allocate array based upon size not capacity</span><br><span class="line">        ensureCapacityInternal(size);</span><br><span class="line"></span><br><span class="line">        Object[] a = elementData;</span><br><span class="line">        // Read in all elements in the proper order.</span><br><span class="line">        for (int i=0; i&lt;size; i++) &#123;</span><br><span class="line">            a[i] = s.readObject();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><hr><p><strong>排序</strong> (ArrayList的排序采用的是Array的并归排序)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *  采用array的排序方式：并归排序</span><br><span class="line"> */</span><br><span class="line">@Override</span><br><span class="line">@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">public void sort(Comparator&lt;? super E&gt; c) &#123;</span><br><span class="line">    final int expectedModCount = modCount;</span><br><span class="line">    Arrays.sort((E[]) elementData, 0, size, c);</span><br><span class="line">    if (modCount != expectedModCount) &#123;</span><br><span class="line">        throw new ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public static &lt;T&gt; void sort(T[] a, int fromIndex, int toIndex,</span><br><span class="line">                            Comparator&lt;? super T&gt; c) &#123;</span><br><span class="line">    if (c == null) &#123;</span><br><span class="line">        sort(a, fromIndex, toIndex);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        rangeCheck(a.length, fromIndex, toIndex);</span><br><span class="line">        if (LegacyMergeSort.userRequested)</span><br><span class="line">            legacyMergeSort(a, fromIndex, toIndex, c);</span><br><span class="line">        else</span><br><span class="line">            TimSort.sort(a, fromIndex, toIndex, c, null, 0, 0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static &lt;T&gt; void legacyMergeSort(T[] a, int fromIndex, int toIndex,</span><br><span class="line">                                        Comparator&lt;? super T&gt; c) &#123;</span><br><span class="line">    T[] aux = copyOfRange(a, fromIndex, toIndex);</span><br><span class="line">    if (c==null)</span><br><span class="line">        mergeSort(aux, a, fromIndex, toIndex, -fromIndex);</span><br><span class="line">    else</span><br><span class="line">        mergeSort(aux, a, fromIndex, toIndex, -fromIndex, c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@SuppressWarnings(&#123;&quot;unchecked&quot;, &quot;rawtypes&quot;&#125;)</span><br><span class="line">private static void mergeSort(Object[] src,</span><br><span class="line">                              Object[] dest,</span><br><span class="line">                              int low,</span><br><span class="line">                              int high,</span><br><span class="line">                              int off) &#123;</span><br><span class="line">    int length = high - low;</span><br><span class="line"></span><br><span class="line">    // Insertion sort on smallest arrays</span><br><span class="line">    if (length &lt; INSERTIONSORT_THRESHOLD) &#123;</span><br><span class="line">        for (int i=low; i&lt;high; i++)</span><br><span class="line">            for (int j=i; j&gt;low &amp;&amp;</span><br><span class="line">                     ((Comparable) dest[j-1]).compareTo(dest[j])&gt;0; j--)</span><br><span class="line">                swap(dest, j, j-1);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Recursively sort halves of dest into src</span><br><span class="line">    int destLow  = low;</span><br><span class="line">    int destHigh = high;</span><br><span class="line">    low  += off;</span><br><span class="line">    high += off;</span><br><span class="line">    int mid = (low + high) &gt;&gt;&gt; 1;</span><br><span class="line">    mergeSort(dest, src, low, mid, -off);</span><br><span class="line">    mergeSort(dest, src, mid, high, -off);</span><br><span class="line"></span><br><span class="line">    // If list is already sorted, just copy from src to dest.  This is an</span><br><span class="line">    // optimization that results in faster sorts for nearly ordered lists.</span><br><span class="line">    if (((Comparable)src[mid-1]).compareTo(src[mid]) &lt;= 0) &#123;</span><br><span class="line">        System.arraycopy(src, low, dest, destLow, length);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Merge sorted halves (now in src) into dest</span><br><span class="line">    for(int i = destLow, p = low, q = mid; i &lt; destHigh; i++) &#123;</span><br><span class="line">        if (q &gt;= high || p &lt; mid &amp;&amp; ((Comparable)src[p]).compareTo(src[q])&lt;=0)</span><br><span class="line">            dest[i] = src[p++];</span><br><span class="line">        else</span><br><span class="line">            dest[i] = src[q++];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ArrayList 是平时常用的数据存储结构，它基于动态数组，支持随机访问，值得一提的是：&lt;strong&gt;它是不安全的&lt;/strong&gt;。造成这种不安全的原因主要是：在在多线程环境下，向 ArrayList 添加或移除时，会产生数组越界等问题。推荐使用 Vector、CopyOnWriteArrayList 代替。&lt;/p&gt;
&lt;h3 id=&quot;ArrayList-与-Array-区别：&quot;&gt;&lt;a href=&quot;#ArrayList-与-Array-区别：&quot; class=&quot;headerlink&quot; title=&quot;ArrayList 与 Array 区别：&quot;&gt;&lt;/a&gt;ArrayList 与 Array 区别：&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Array 包含的是基本类型和对象类型，而ArrayList 只能包含对象类型&lt;/li&gt;
&lt;li&gt;Array 的大小的是固定的，所以在定义数组的时候尽量确定需要的数组大小，而ArrayList 的大小是动态变化的，当容量不足时能自动扩容&lt;/li&gt;
&lt;li&gt;ArrayList 可以看作Array的增强版，提供了更多的方法和特性，在查找等操作上更方便&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;public class ArrayList&amp;lt;E&amp;gt; extends AbstractList&amp;lt;E&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        implements List&amp;lt;E&amp;gt;, RandomAccess, Cloneable, java.io.Serializable&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://heiku.github.io/tags/Java/"/>
    
      <category term="源码分析" scheme="https://heiku.github.io/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
      <category term="ArrayList" scheme="https://heiku.github.io/tags/ArrayList/"/>
    
  </entry>
  
  <entry>
    <title>新博客 启动</title>
    <link href="https://heiku.github.io/2018/03/10/new-blog/"/>
    <id>https://heiku.github.io/2018/03/10/new-blog/</id>
    <published>2018-03-10T01:58:26.000Z</published>
    <updated>2018-07-23T08:02:35.503Z</updated>
    
    <content type="html"><![CDATA[<p>花了一上午时间，通过参照  <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>  的文档和各种 <a href="https://github.com/limedroid/HexoLearning" target="_blank" rel="noopener">网上资料</a> ，终于将博客搭建起来， 由于没仔细参照文档，耽误了好多时间。期间接触到了 Markdown 这种写作语法，写起来还是挺轻便的。以后的新博客都写在这里，旧的博客不再更新。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;花了一上午时间，通过参照  &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;  的文档和各种 &lt;a href=&quot;https://github.com/limedroid/HexoLearni
      
    
    </summary>
    
    
      <category term="杂谈" scheme="https://heiku.github.io/tags/%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
</feed>
