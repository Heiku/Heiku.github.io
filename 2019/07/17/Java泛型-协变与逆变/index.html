<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  
  <title>Java泛型-协变与逆变 | Heiku</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="概念协变与逆变 (Covariance and contravariance ) 用来描述具有父/子关系的类型通过类型转换之后的继承关系。   即：如果A、B表示类型，f()表示类型转换，$\subseteq$ 表示子类与父类之间的继承关系，那么有以下定义：协变(Covariance)：当 A $\subseteq$ B时，f(A)$\subseteq$f(B)成立；逆变(contravarian">
<meta name="keywords" content="Java,泛型,协变与逆变">
<meta property="og:type" content="article">
<meta property="og:title" content="Java泛型-协变与逆变">
<meta property="og:url" content="https://heiku.github.io/2019/07/17/Java泛型-协变与逆变/index.html">
<meta property="og:site_name" content="Heiku">
<meta property="og:description" content="概念协变与逆变 (Covariance and contravariance ) 用来描述具有父/子关系的类型通过类型转换之后的继承关系。   即：如果A、B表示类型，f()表示类型转换，$\subseteq$ 表示子类与父类之间的继承关系，那么有以下定义：协变(Covariance)：当 A $\subseteq$ B时，f(A)$\subseteq$f(B)成立；逆变(contravarian">
<meta property="og:locale" content="default">
<meta property="og:image" content="https://heiku.github.io/.io//泛型-上界.png">
<meta property="og:image" content="https://heiku.github.io/.io//泛型-下界.png">
<meta property="og:updated_time" content="2019-07-18T13:05:13.337Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Java泛型-协变与逆变">
<meta name="twitter:description" content="概念协变与逆变 (Covariance and contravariance ) 用来描述具有父/子关系的类型通过类型转换之后的继承关系。   即：如果A、B表示类型，f()表示类型转换，$\subseteq$ 表示子类与父类之间的继承关系，那么有以下定义：协变(Covariance)：当 A $\subseteq$ B时，f(A)$\subseteq$f(B)成立；逆变(contravarian">
<meta name="twitter:image" content="https://heiku.github.io/.io//泛型-上界.png">
  
    <link rel="alternative" href="/atom.xml" title="Heiku" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css">
  

</head></html>
<body>
  <div id="container">
    <div id="wrap">
      <div class="outer">
        <section id="main"><article id="post-Java泛型-协变与逆变" class="article article-type-post" itemscope itemprop="blogPost">
  
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Java泛型-协变与逆变
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2019/07/17/Java泛型-协变与逆变/" class="article-date">
  <time datetime="2019-07-17T14:30:27.000Z" itemprop="datePublished">2019-07-17</time>
</a>
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><strong>协变与逆变 (Covariance and contravariance )</strong> 用来描述具有父/子关系的类型通过类型转换之后的继承关系。  </p>
<p>即：如果A、B表示类型，f()表示类型转换，$\subseteq$ 表示子类与父类之间的继承关系，那么有以下定义：<br><strong>协变(Covariance)</strong>：当 A $\subseteq$ B时，f(A)$\subseteq$f(B)成立；<br><strong>逆变(contravariance)</strong>：当A $\subseteq$ B时，f(B)$\subseteq$f(A)成立；<br><strong>不变(invariance)</strong>：当A $\subseteq$ B时，以上均不成立，那么f(A)与f(B)之间不存在继承关系；</p>
<p>先定义几个类之间的继承关系</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Fruit&#123;&#125;       // base</span><br><span class="line"></span><br><span class="line">class Apple extends Fruit&#123;&#125;</span><br><span class="line"></span><br><span class="line">class Lemon extends Fruit&#123;&#125;</span><br><span class="line">class Eureka extends Lemon&#123;&#125;</span><br></pre></td></tr></table></figure>
<h2 id="数组是协变的"><a href="#数组是协变的" class="headerlink" title="数组是协变的"></a>数组是协变的</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Fruit[] fruit = new Lemon[20];</span><br><span class="line"></span><br><span class="line">fruit[0] = new Lemon();</span><br><span class="line">fruit[1] = new Eureka();</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line">    fruit[2] = new Fruit();</span><br><span class="line">&#125;catch (Exception e)&#123;</span><br><span class="line">    System.out.println(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">java.lang.ArrayStoreException: Baisc.type.generic.Fruit</span><br></pre></td></tr></table></figure>
<p>首先，创建的数组为Lemon数组，同时在栈中创建一个fruit的引用指向lemon[]。因为实际数组为 Lemon Class，所以我们可以放入 Lemon及子类 Eureka，而当我们将Fruit基类放入时，排除类型异常，因为并不是所有Fruit都属于Lemon。</p>
<p>那么，为什么编译器不会发现问题呢？因为编译器会将在存储表中标识fruit是Fruit[]类型，所以编译期间通过，但在运行中才会去判断数组元素的类型约束。</p>
<h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>为了解决这中问题，Java从引入泛型去解决编译期间的类型转换问题。但事实上，Java中的泛型不像 C++中的 <strong>模板泛型</strong> 一样，是真实的模板实例，十分灵活易于拓展。相反，而是一种语法糖，在编译期间会进行 <strong>类型擦除</strong>，最终都会替换成 <strong>非泛型上界</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Lemon&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">在编译期间都会进行类型擦除，最终都会转为 class java.util.ArrayList 这样无类型的集合类</span><br></pre></td></tr></table></figure>
<h2 id="So，泛型是不变的"><a href="#So，泛型是不变的" class="headerlink" title="So，泛型是不变的"></a>So，泛型是不变的</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">List&lt;Fruit&gt; list = new ArrayList&lt;Apple&gt;();     // 编译错误</span><br><span class="line"></span><br><span class="line">正因为泛型在编译期间进行了类型擦除，所以在编译期间会统一类型，所以会在编译期间提示错误。</span><br></pre></td></tr></table></figure>
<p>那么，如果我想表示这种类型转换的话，那该怎么办？这时就需要通配符。</p>
<h2 id="泛型中的通配符和边界"><a href="#泛型中的通配符和边界" class="headerlink" title="泛型中的通配符和边界"></a>泛型中的通配符和边界</h2><ul>
<li><strong>&lt; ? extend T &gt;</strong>: 上界通配符 ( Upper Bounds Wildcards )</li>
<li><strong>&lt; ? super T &gt;</strong>: 下界通配符 ( Lower Bounds Wildcards )</li>
</ul>
<h3 id="上界"><a href="#上界" class="headerlink" title="上界"></a>上界</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">List&lt;? extends Fruit&gt; = new ArrayList&lt;Lemon&gt;();      // 编译成功</span><br></pre></td></tr></table></figure>
<p><strong>为什么说是上界通配符呢？</strong>  </p>
<p>我们把之前列出的几个类通过一颗继承关系树表示，将会得到下面的结果：</p>
<p><img src="/.io//泛型-上界.png" alt></p>
<p><strong>&lt;? extend Fruit&gt;</strong> 指明了泛型的上界为Fruit，在上面的例子中，&lt; ? extends Fruit &gt; 表示了一个能装水果或者属于水果的盘子。即放得下 List&lt; Fruit &gt; 以及 List&lt; Lemon &gt;的基类。</p>
<h3 id="下界"><a href="#下界" class="headerlink" title="下界"></a>下界</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">List&lt;? super Fruit&gt; list = new ArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure>
<p><img src="/.io//泛型-下界.png" alt></p>
<p>下界表示的是一个相反的概念，表示的是当前的 list能存放的是 Fruit的基类。</p>
<h3 id="PECS-原则"><a href="#PECS-原则" class="headerlink" title="PECS 原则"></a>PECS 原则</h3><p><strong>producer extends,consumer super  –《Effective Java》</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">List&lt;? extends Fruit&gt; list = new ArrayList&lt;Lemon&gt;();</span><br><span class="line"></span><br><span class="line">Object object = list.get(0);</span><br><span class="line">Fruit fruit = list.get(1);</span><br><span class="line">Lemon lemon = list.get(2);      // 1 编译错误</span><br><span class="line"></span><br><span class="line">list.add(new Lemon());          // 2 编译错误</span><br><span class="line">list.add(new Fruit());          // 3 编译错误</span><br></pre></td></tr></table></figure>
<p><strong>&lt; ? extends Fruit &gt; 只能存，不能放</strong></p>
<ul>
<li>get( ) : extends 规定了容器的上界，所以容器中获取的类型只能是 Fruit 或是 它的基类即 Object。</li>
<li>set( ) : 由于编译器不知道 List&lt;? extends Fruit&gt; 到底指的是什么类型，有可能是 Apple， 也有可能是 Lemon，所以会先在 List上打上标识符：<strong>CAP#1</strong>，表示捕获一个 Fruit 或 Fruit的子类，但却没有具体的类型可以与这个 <strong>CAP#1</strong> 进行匹配，所以在执行这种向上转型的时候，将散失其中传递对象的能力。  </li>
</ul>
<p>类比于数组，当我们将 Lemon[] 向上转型为 Fruit[]的时候，在运行期间往数组中添加 fruit会抛出异常，而泛型的时候，就是将这种类型检查移到编译期间，拒绝一切不安全的类型协变。</p>
<p><strong>&lt; ? super Fruit &gt; 只能放，不能读</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">List&lt;? super Fruit&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">list.add(new Eureka());</span><br><span class="line">list.add(new Lemon());</span><br><span class="line">list.add(new Fruit());</span><br><span class="line"></span><br><span class="line">Lemon lemon = list.get(0);      // 编译失败</span><br><span class="line">Fruit fruit = list.get(0);      // 编译失败</span><br><span class="line">    </span><br><span class="line">Object obj = list.get(0);</span><br></pre></td></tr></table></figure>
<ul>
<li>get ( ) : 下界规定了 List 存放的 元素的最小粒度的下限，即元素既然是 Fruit的基类，那么往里面放力度比 Fruit的都可以。</li>
<li>set ( ) : 由于类型丢失，导致存放的时候只有 基类 Object才能放下。</li>
</ul>

      

      
        
    </div>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2018/08/31/装饰者模式/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Decorator pattern</div>
    </a>
  
</nav>

  
</article>


</section>
        <aside id="sidebar">
  <nav class="menus">
  	<ul>
  		<li><a href="/"><i class="icon icon-home"></i></a></li>
  		
			<li><a href="/archives"><i class="icon icon-fenlei"></i></a></li>
  		
  		
			<li><a href="/tags"><i class="icon icon-tag"></i></a></li>
  		
  		
  			<li><a href="https://github.com/Heiku" target="_blank"><i class="icon icon-github"></i></a></li>
  		
  	</ul>
  </nav>
  <a id="go-top" href="#"><i class="icon icon-up"></i></a>
</aside>

      </div>
      <footer id="footer">
  
	<div id="footer-info" class="inner">
	  &copy; 2019 John Doe 
	  - Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
	  - Theme <a href="https://github.com/hejianxian/hexo-theme-jane/" target="_blank">Jane</a>
	</div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
    <a href="/tags" class="mobile-nav-link">Tag</a>
  
    <a href="https://github.com/Heiku" class="mobile-nav-link">Github</a>
  
</nav>
    

<script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>