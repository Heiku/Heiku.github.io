<!DOCTYPE html>
<html lang="zh-cmn-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>SpringBoot 启动分析-refresh() | Heiku</title>
  
  
  <!--link rel="stylesheet" href="//cdn.jsdelivr.net/highlight.js/9.10.0/styles/github-gist.min.css"-->
  <link rel="stylesheet" href="//cdn.jsdelivr.net/highlight.js/9.10.0/styles/github-gist.min.css">
  <link rel="stylesheet" href="/css/style.css"><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</head>

<body>
<!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="Shell">
    <aside class='SideBar'>
    <section class='avatar' style="background-image: url(/assets/background.jpg)">
        <div class='av-pic' style="background-image: url(/assets/head.jpg)">
        </div>
    </section>
    <section class='menu'>
        <div>Heiku</div>
        
        <ul>
          
            <a href="/" class="Btn">
              <li>Home</li>
            </a>  
          
            <a href="/archives/" class="Btn">
              <li>Archive</li>
            </a>  
          
            <a href="/tags" class="Btn">
              <li>Tags</li>
            </a>  
          
            <a href="/about/" class="Btn">
              <li>About</li>
            </a>  
          
            <a href="https://github.com/Heiku" class="Btn">
              <li>Github</li>
            </a>  
          
        </ul>
    </section>
    <section class="media">
        
            
                <a href="https://github.com/Heiku">
                    <img src="/assets/github.svg" />
                </a>
            
        
    </section>
</aside>

    <div class="container">
        <div data-pager-shell>
            <div>
  <article class='ContentView'>
    <header class='PageTitle'>
        <h1>SpringBoot 启动分析-refresh()</h1>
    </header>

    <section>
      <h2 id="refresh"><a href="#refresh" class="headerlink" title="refresh()"></a>refresh()</h2><p><br></p>
<p>上一篇分析 <code>SpringBoot</code> 启动过程中的 构造过程及 <code>run()</code>，在构造的过程中，主要是根据应用程序的类型设置 <code>WebApplicationType</code>，同时根据 <code>spring.factories</code>的配置读取初始化容器的一些监听器 <code>listeners</code> 和初始化器 <code>initializers</code>。  </p>
<p>而在 <code>run()</code>中，主要是对应用上下文 <code>ApplicationContext</code> 创建并进行初始化，设置 <code>WebApplicationType</code>对应的 <code>environment</code>，然后 <code>refreshContext(context)</code> ，最后加载 <code>listeners start(),running</code> 并加入 <code>SpringRunners</code>.  </p>
<p>在 <code>refreshContext(context)</code> 主要有下面几个工作：</p>
<ol>
<li><a href="#prepareRefresh">prepareRefresh()</a></li>
<li><a href="#prepareBeanFactory">prepareBeanFactory()</a></li>
<li><a href="#postProcessBeanFactory">postProcessBeanFactory()</a></li>
<li><a href="#invokeBeanFactoryPostProcessors">invokeBeanFactoryPostProcessors()</a></li>
<li><a href="#registerBeanPostProcessors">registerBeanPostProcessors()</a></li>
<li><a href="#initMessageSource">initMessageSource()</a></li>
<li><a href="#initApplicationEventMulticaster">initApplicationEventMulticaster()</a></li>
<li><a href="#onRefresh">onRefresh()</a></li>
<li><a href="#registerListeners">registerListeners()</a></li>
<li><a href="#finishBeanFactoryInitialization">finishBeanFactoryInitialization()</a></li>
<li><a href="#finishRefresh">finishRefresh()</a><br><br></li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">  public void refresh() throws BeansException, IllegalStateException &#123;</span><br><span class="line">// 获取监视器锁</span><br><span class="line">      synchronized(this.startupShutdownMonitor) &#123;</span><br><span class="line">      </span><br><span class="line">      	// 刷新上下文前的准备，记录状态，验证必要属性</span><br><span class="line">          this.prepareRefresh();</span><br><span class="line">          ConfigurableListableBeanFactory beanFactory = this.obtainFreshBeanFactory();</span><br><span class="line">          </span><br><span class="line">          // 配置标准的 beanFactory，设置 classloader, bean表达解析器，同时注册重要的bean组件</span><br><span class="line">          this.prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">          try &#123;</span><br><span class="line">          	// 模板方法，交由子类对 beanFactory 进行后置处理</span><br><span class="line">              this.postProcessBeanFactory(beanFactory);</span><br><span class="line">              </span><br><span class="line">              // 调用 beanFactoryPostPorcessor </span><br><span class="line">              this.invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line">              </span><br><span class="line">              // 注册容器中的 beanPostProcessors</span><br><span class="line">              this.registerBeanPostProcessors(beanFactory);</span><br><span class="line">              </span><br><span class="line">              // 初始化国际工具类 MessageSource</span><br><span class="line">              this.initMessageSource();</span><br><span class="line">              </span><br><span class="line">              // 初始化并注册事件广播器 ApplicationEventMulticaster</span><br><span class="line">              this.initApplicationEventMulticaster();</span><br><span class="line">              </span><br><span class="line">              // 模板方法，根据应用的具体类型交由子类具体处理，如果是web类型，通常是构建webServer</span><br><span class="line">              this.onRefresh();</span><br><span class="line">              </span><br><span class="line">              // 注册容器中的监听器，包括spring.factories 和 自定义 bean listenr</span><br><span class="line">              this.registerListeners();</span><br><span class="line">              </span><br><span class="line">              // 实例化所有的单例 bean （非 Lazy）,beanPostProcessor 开始起作用</span><br><span class="line">              this.finishBeanFactoryInitialization(beanFactory);</span><br><span class="line">              </span><br><span class="line">              // refresh() 后的额外工作，包括清除resource cahce，注册 LifeCycleProcessor及发布上下文已经刷新的事件 ContexntRefreshedEvent</span><br><span class="line">              this.finishRefresh();</span><br><span class="line">          &#125; catch (BeansException var9) &#123;</span><br><span class="line">		</span><br><span class="line">		// 如果刷新上下文的过程中，出现异常，那么销毁所有已经创建的 bean</span><br><span class="line">              this.destroyBeans();</span><br><span class="line">              </span><br><span class="line">              // 重置 context 的刷新状态，即将 active = false</span><br><span class="line">              this.cancelRefresh(var9);</span><br><span class="line">              throw var9;</span><br><span class="line">          &#125; finally &#123;</span><br><span class="line">          	// 无论失败与否，已经不再需要 bean metadata，重置 Spring 的内核缓存</span><br><span class="line">              this.resetCommonCaches();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p> <br></p>
<h3 id="prepareRefresh"><a href="#prepareRefresh" class="headerlink" title="prepareRefresh()"></a>prepareRefresh()</h3><p>prepareRefresh()  是为 refresh() 进行了准备工作，主要准备工作有：</p>
<ol>
<li><p>记录 Spring 容器的启动时间，同时设置 active , closed 的状态</p>
</li>
<li><p>初始化属性源信息 (propertySources)，及验证当前环境中的必要的属性是否存在</p>
</li>
<li><p>设置 earlyApplicationListeners &amp; earlyApplicationEvents 属性列表</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">  protected void prepareRefresh() &#123;</span><br><span class="line">  	// 记录启动时间</span><br><span class="line">      this.startupDate = System.currentTimeMillis();</span><br><span class="line">      </span><br><span class="line">      // 设置关闭状态，及开启状态</span><br><span class="line">      this.closed.set(false);</span><br><span class="line">      this.active.set(true);</span><br><span class="line"></span><br><span class="line">   // 初始化属性源信息</span><br><span class="line">      this.initPropertySources();</span><br><span class="line">      </span><br><span class="line">      // 验证当前环境中的必要属性是否存在</span><br><span class="line">      this.getEnvironment().validateRequiredProperties();</span><br><span class="line">      </span><br><span class="line">      // 判断 earlyApplicationListeners 是否存在，是的话加入到应用程序监听器 ApplicationListeners中，</span><br><span class="line">      // 否则的话创建新的对象</span><br><span class="line">      if (this.earlyApplicationListeners == null) &#123;</span><br><span class="line">          this.earlyApplicationListeners = new LinkedHashSet(this.applicationListeners);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">          this.applicationListeners.clear();</span><br><span class="line">          this.applicationListeners.addAll(this.earlyApplicationListeners);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">// 创建 earlyApplicationEvents </span><br><span class="line">      this.earlyApplicationEvents = new LinkedHashSet();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h3 id="prepareBeanFactory"><a href="#prepareBeanFactory" class="headerlink" title="prepareBeanFactory()"></a>prepareBeanFactory()</h3><p>prepareBeanFactory() 获取了容器中的 beanFactory 并进行以下操作：</p>
<ol>
<li>设置 bean 加载器 BeanClassLoader（用于 Bean 的加载），bean 表达式解析器 BeanExpressionResolver </li>
<li>添加注册属性编辑器 propertyEditorRegistrar，添加 BeanPostProcessor （ApplicationContextAwareProcessor）</li>
<li>将几个重要的 bean ( BeanFactory, ResourceLoader, ApplicationEventPublisher, ApplicationContext ) 加载到容器中，后续使用</li>
<li>添加 ApplicationListenerDetector 到 beanFactory 中的 beanPostProcessor 列表中</li>
<li>检查并注入其他的属性信息，如 loadTimeWeaver, environment 等</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">protected void prepareBeanFactory(ConfigurableListableBeanFactory beanFactory) &#123;</span><br><span class="line">		// 设置 beanClassLoader</span><br><span class="line">        beanFactory.setBeanClassLoader(this.getClassLoader());</span><br><span class="line">        </span><br><span class="line">        // 设置 bean 表达解析器（用于处理定义 Bean 过程中的一些解析表达式： 例如 #&#123;sqlProperties&#125; ）</span><br><span class="line">        beanFactory.setBeanExpressionResolver(new StandardBeanExpressionResolver(beanFactory.getBeanClassLoader()));</span><br><span class="line">        </span><br><span class="line">        // 添加注册属性编辑器</span><br><span class="line">        beanFactory.addPropertyEditorRegistrar(new ResourceEditorRegistrar(this, this.getEnvironment()));</span><br><span class="line">        </span><br><span class="line">        // 添加 ApplicationContextAwareProcessor 到 beanPostProcessors 列表中</span><br><span class="line">        beanFactory.addBeanPostProcessor(new ApplicationContextAwareProcessor(this));</span><br><span class="line">        </span><br><span class="line">        /** 取消 EnvironmentAware, EmbeddedValueResolverAware, ResourceLoaderAware,</span><br><span class="line">       	 *	AApplicationEventPublisherAware, MessageSourceAware, ApplicationContextAware </span><br><span class="line">       	 *	这些接口的依赖注入，因为这些接口的属性设置工作已经被 ApplicationContextAwareProcessor代替</span><br><span class="line">       	 *</span><br><span class="line">       	 *	这些接口将会保存在 beanFactory 中的 ignoredDependencyInterfaces 列表中</span><br><span class="line">       	 */ 	</span><br><span class="line">        beanFactory.ignoreDependencyInterface(EnvironmentAware.class);</span><br><span class="line">        beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware.class);</span><br><span class="line">        beanFactory.ignoreDependencyInterface(ResourceLoaderAware.class);</span><br><span class="line">        beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class);</span><br><span class="line">        beanFactory.ignoreDependencyInterface(MessageSourceAware.class);</span><br><span class="line">        beanFactory.ignoreDependencyInterface(ApplicationContextAware.class);</span><br><span class="line">        </span><br><span class="line">        // 添加重要的 bean 到容器中，BeanFactory, ResourceLoader,</span><br><span class="line">        			ApplicationEventPublisher, ApplicationContext</span><br><span class="line">          这里可以设置为 this，是因为都实现了对应接口中的方法</span><br><span class="line">          </span><br><span class="line">          这些类属性将会被保存在 beanFactory 中的 resolvableDependencies map表中</span><br><span class="line">        beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory);</span><br><span class="line">        beanFactory.registerResolvableDependency(ResourceLoader.class, this);</span><br><span class="line">        beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, this);</span><br><span class="line">        beanFactory.registerResolvableDependency(ApplicationContext.class, this);</span><br><span class="line">        </span><br><span class="line">        // 添加 ApplicationListenerDetector 到 beanFactory 中的 beanPostProcessors 列表中</span><br><span class="line">        beanFactory.addBeanPostProcessor(new ApplicationListenerDetector(this));</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">		// 检查代码织入,通常用于 Aspect切面的准备工作</span><br><span class="line">        if (beanFactory.containsBean(&quot;loadTimeWeaver&quot;)) &#123;</span><br><span class="line">            beanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory));</span><br><span class="line">            beanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 检查并设置 localBean，environment, systemProperties, systemEnvironment</span><br><span class="line">        if (!beanFactory.containsLocalBean(&quot;environment&quot;)) &#123;</span><br><span class="line">            beanFactory.registerSingleton(&quot;environment&quot;, this.getEnvironment());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (!beanFactory.containsLocalBean(&quot;systemProperties&quot;)) &#123;</span><br><span class="line">            beanFactory.registerSingleton(&quot;systemProperties&quot;, this.getEnvironment().getSystemProperties());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (!beanFactory.containsLocalBean(&quot;systemEnvironment&quot;)) &#123;</span><br><span class="line">            beanFactory.registerSingleton(&quot;systemEnvironment&quot;, this.getEnvironment().getSystemEnvironment());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    </span><br><span class="line">    // ApplicationContextAwareProcessor extend BeanPostProcessor</span><br><span class="line">    // 在 postProcessBeforeInitialization()的时候，调用 invokeAwareInterfaces</span><br><span class="line">    // 根据 bean 的类型设置对应接口的属性信息</span><br><span class="line">    private void invokeAwareInterfaces(Object bean) &#123;</span><br><span class="line">        if (bean instanceof Aware) &#123;</span><br><span class="line">            if (bean instanceof EnvironmentAware) &#123;</span><br><span class="line">                ((EnvironmentAware)bean).setEnvironment(this.applicationContext.getEnvironment());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (bean instanceof EmbeddedValueResolverAware) &#123;</span><br><span class="line">                ((EmbeddedValueResolverAware)bean).setEmbeddedValueResolver(this.embeddedValueResolver);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (bean instanceof ResourceLoaderAware) &#123;</span><br><span class="line">                ((ResourceLoaderAware)bean).setResourceLoader(this.applicationContext);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (bean instanceof ApplicationEventPublisherAware) &#123;</span><br><span class="line">                ((ApplicationEventPublisherAware)bean).setApplicationEventPublisher(this.applicationContext);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (bean instanceof MessageSourceAware) &#123;</span><br><span class="line">                ((MessageSourceAware)bean).setMessageSource(this.applicationContext);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (bean instanceof ApplicationContextAware) &#123;</span><br><span class="line">                ((ApplicationContextAware)bean).setApplicationContext(this.applicationContext);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h3 id="postProcessBeanFactory"><a href="#postProcessBeanFactory" class="headerlink" title="postProcessBeanFactory()"></a>postProcessBeanFactory()</h3><p>postProcessBeanFactory() 主要是对设置属性后的 beanFactory 进行了后续的操作， 不同的应用程序类型会由不同的类进行操作，例如在 Servlet 类型中，对应的操作类为 AnnotationConfigServletWebServerApplicationContext， 而在 Reactive 中对应的则是 AnnotationConfigReactiveWebServerApplicationContext，区别在于调用的父类方法 postProcessBeanFactory()上，而读取注册 basePackages、annotatedClass 属性上的 bean 组件都是相同的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// AnnotationConfigReactiveWebServerApplicationContext.class </span><br><span class="line">protected void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) &#123;</span><br><span class="line">		// 调用父类 AbstractApplicationContext的方法实现</span><br><span class="line">        super.postProcessBeanFactory(beanFactory);</span><br><span class="line">        </span><br><span class="line">        // 如果设置了 basePackages 属性，那么调用 ClassPathBeanDefinitionScanner 扫描 basePackages 下的bean组件，并注册到容器中</span><br><span class="line">        if (!ObjectUtils.isEmpty(this.basePackages)) &#123;</span><br><span class="line">            this.scanner.scan(this.basePackages);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">		// 如果设置了 annotatedClasses 属性，那么调用 AnnotatedBeanDefinitionReader 注册这些带注解的bean信息</span><br><span class="line">        if (!this.annotatedClasses.isEmpty()) &#123;</span><br><span class="line">            this.reader.register(ClassUtils.toClassArray(this.annotatedClasses));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h3 id="invokeBeanFactoryPostProcessors"><a href="#invokeBeanFactoryPostProcessors" class="headerlink" title="invokeBeanFactoryPostProcessors()"></a>invokeBeanFactoryPostProcessors()</h3><ol>
<li>BeanFactoryPostProcessors 可以对容器中加载 bean，进行属性修改，这里得bean 还未实例化，更没有初始，允许修改 bean 定义</li>
<li>BeanDefinitionRegistryPostProcessor 是对于 BeanFactoryPostProcessor 的扩展，允许修改 bean 注册器，也就是说可以在 BeanFactoryPostProcessor 之前对 bean 进行定义的修改</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line">public interface BeanFactoryPostProcessor &#123;</span><br><span class="line">    void postProcessBeanFactory(ConfigurableListableBeanFactory var1) throws BeansException;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public interface BeanDefinitionRegistryPostProcessor extends BeanFactoryPostProcessor &#123;</span><br><span class="line">    void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry var1) throws BeansException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>invokeBeanFactoryPostProcessors() 主要是调用获取当前容器中得 beanPostProessor ( BeanFactoryPostProcessor &amp; BeanDefinitionRegistryPostProcessor ) ，根据 postProcessor 的接口实现 PriorityOrdered &amp; Ordered 进行排序并调用，实现逻辑中 beanDefinitionRegistryPostProcessor 会在 beanFactoryPostProcessor 之前进行调用，保证了两种接口之间的调用顺序.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br></pre></td><td class="code"><pre><span class="line">// 具体的调用过程被委托到 PostProcessorRegistrationDelegate.class 下</span><br><span class="line">public static void invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory beanFactory, List&lt;BeanFactoryPostProcessor&gt; beanFactoryPostProcessors) &#123;</span><br><span class="line"></span><br><span class="line">		// 创建集合 processedBeans 用于保存所有处理过的 postProcessor name</span><br><span class="line">       Set&lt;String&gt; processedBeans = new HashSet();</span><br><span class="line">       </span><br><span class="line">       // 定义两个列表分别存放 beanFactoryPostProcessor &amp; beanDefinitionRegistryPostProcessor</span><br><span class="line">       ArrayList regularPostProcessors;</span><br><span class="line">       ArrayList registryProcessors;</span><br><span class="line">       int var9;</span><br><span class="line">       ArrayList currentRegistryProcessors;</span><br><span class="line">       String[] postProcessorNames;</span><br><span class="line">       </span><br><span class="line">       // 如果 beanFactory 属于 beanDefinitionRegistry 的时候，遍历 beanFactoryPostProcessors，区分存储			到 regulatPostProcessors &amp; registryProcessors</span><br><span class="line">       if (beanFactory instanceof BeanDefinitionRegistry) &#123;</span><br><span class="line">           BeanDefinitionRegistry registry = (BeanDefinitionRegistry)beanFactory;</span><br><span class="line">           regularPostProcessors = new ArrayList();</span><br><span class="line">           registryProcessors = new ArrayList();</span><br><span class="line">           Iterator var6 = beanFactoryPostProcessors.iterator();</span><br><span class="line"></span><br><span class="line">		// registryPostPorcessors -&gt; BeanDefinitionRegistryPostProcessor</span><br><span class="line">		// regulatPostProcessors -&gt; BeanFactoryPostProcessor</span><br><span class="line">           while(var6.hasNext()) &#123;</span><br><span class="line">               BeanFactoryPostProcessor postProcessor = (BeanFactoryPostProcessor)var6.next();</span><br><span class="line">               if (postProcessor instanceof BeanDefinitionRegistryPostProcessor) &#123;</span><br><span class="line">                   BeanDefinitionRegistryPostProcessor registryProcessor = (BeanDefinitionRegistryPostProcessor)postProcessor;</span><br><span class="line">                   registryProcessor.postProcessBeanDefinitionRegistry(registry);</span><br><span class="line">                   registryProcessors.add(registryProcessor);</span><br><span class="line">               &#125; else &#123;</span><br><span class="line">                   regularPostProcessors.add(postProcessor);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           </span><br><span class="line">           // 获取所有类型为 BeanDefinitionRegistryPostProcessor 的 bean name</span><br><span class="line">           currentRegistryProcessors = new ArrayList();</span><br><span class="line">           postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);</span><br><span class="line">           String[] var16 = postProcessorNames;</span><br><span class="line">           var9 = postProcessorNames.length;</span><br><span class="line"></span><br><span class="line">		// 先筛选出实现 PriorityOrdered 接口的 beanDefinitionRegistryPostProcessor，</span><br><span class="line">		   并保存在集合 currentRegistryProcessors, processedBeans 中</span><br><span class="line">           int var10;</span><br><span class="line">           String ppName;</span><br><span class="line">           for(var10 = 0; var10 &lt; var9; ++var10) &#123;</span><br><span class="line">               ppName = var16[var10];</span><br><span class="line">               if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123;</span><br><span class="line">                   currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));</span><br><span class="line">                   processedBeans.add(ppName);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">		</span><br><span class="line">		// 根据 priorityOrdered 的优先级进行排序</span><br><span class="line">           sortPostProcessors(currentRegistryProcessors, beanFactory);</span><br><span class="line">           registryProcessors.addAll(currentRegistryProcessors);</span><br><span class="line">           </span><br><span class="line">           // 遍历调用执行所有的 PriorityOrdered BeanDefinitionRegistryProcessors</span><br><span class="line">           invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);</span><br><span class="line">           currentRegistryProcessors.clear();</span><br><span class="line">           postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);</span><br><span class="line">           var16 = postProcessorNames;</span><br><span class="line">           var9 = postProcessorNames.length;</span><br><span class="line"></span><br><span class="line">		// 重新获取并筛选出实现 Ordered 接口的 BeanDefinitionRegistryPostProcessors</span><br><span class="line">           for(var10 = 0; var10 &lt; var9; ++var10) &#123;</span><br><span class="line">               ppName = var16[var10];</span><br><span class="line">               if (!processedBeans.contains(ppName) &amp;&amp; beanFactory.isTypeMatch(ppName, Ordered.class)) &#123;</span><br><span class="line">                   currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));</span><br><span class="line">                   processedBeans.add(ppName);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">		// 根据 Ordered 优先级排序，然后遍历调用</span><br><span class="line">           sortPostProcessors(currentRegistryProcessors, beanFactory);</span><br><span class="line">           registryProcessors.addAll(currentRegistryProcessors);</span><br><span class="line">           invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);</span><br><span class="line">           currentRegistryProcessors.clear();</span><br><span class="line">           boolean reiterate = true;</span><br><span class="line"></span><br><span class="line">		// 找到其余的 BeanDefinitionRegistryPostProcessor, 进行排序并注册调用</span><br><span class="line">           while(reiterate) &#123;</span><br><span class="line">               reiterate = false;</span><br><span class="line">               postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);</span><br><span class="line">               String[] var19 = postProcessorNames;</span><br><span class="line">               var10 = postProcessorNames.length;</span><br><span class="line"></span><br><span class="line">               for(int var26 = 0; var26 &lt; var10; ++var26) &#123;</span><br><span class="line">                   String ppName = var19[var26];</span><br><span class="line">                   if (!processedBeans.contains(ppName)) &#123;</span><br><span class="line">                       currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));</span><br><span class="line">                       processedBeans.add(ppName);</span><br><span class="line">                       reiterate = true;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               sortPostProcessors(currentRegistryProcessors, beanFactory);</span><br><span class="line">               registryProcessors.addAll(currentRegistryProcessors);</span><br><span class="line">               invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);</span><br><span class="line">               currentRegistryProcessors.clear();</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">		// 因为 BeanDefinitionRegistryPostProcessors 实现了 BeanFactoryPostProcessor 中的方法，</span><br><span class="line">		  所以这里调用在接口中实现的 postProcessBeanFactory() </span><br><span class="line">           invokeBeanFactoryPostProcessors((Collection)registryProcessors, (ConfigurableListableBeanFactory)beanFactory);</span><br><span class="line">           invokeBeanFactoryPostProcessors((Collection)regularPostProcessors, (ConfigurableListableBeanFactory)beanFactory);</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">       </span><br><span class="line">       // 如果当前 beanFactroy 不是 beanDefinitionRegistry，则直接执行 BeanFactoryPostProcessor 接口</span><br><span class="line">           invokeBeanFactoryPostProcessors((Collection)beanFactoryPostProcessors, (ConfigurableListableBeanFactory)beanFactory);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	// 接着就是获取所有类型为 BeanFactoryPostProcessor 的 bean name</span><br><span class="line">       String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanFactoryPostProcessor.class, true, false);</span><br><span class="line">       </span><br><span class="line">       // 复用集合，用 regularPostProcessors 存储实现接口 PriorityOrdered 的 beanFactoryPostProcessor，</span><br><span class="line">       	用 registeyProcessors 存储是新建接口 Ordered 的 beanFactoryPostProcessor</span><br><span class="line">       regularPostProcessors = new ArrayList();</span><br><span class="line">       registryProcessors = new ArrayList();</span><br><span class="line">       currentRegistryProcessors = new ArrayList();</span><br><span class="line">       postProcessorNames = postProcessorNames;</span><br><span class="line">       int var20 = postProcessorNames.length;</span><br><span class="line"></span><br><span class="line">	// 遍历根据实现的接口进行分组</span><br><span class="line">       String ppName;</span><br><span class="line">       for(var9 = 0; var9 &lt; var20; ++var9) &#123;</span><br><span class="line">           ppName = postProcessorNames[var9];</span><br><span class="line">           if (!processedBeans.contains(ppName)) &#123;</span><br><span class="line">               if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123;</span><br><span class="line">                   regularPostProcessors.add(beanFactory.getBean(ppName, BeanFactoryPostProcessor.class));</span><br><span class="line">               &#125; else if (beanFactory.isTypeMatch(ppName, Ordered.class)) &#123;</span><br><span class="line">                   registryProcessors.add(ppName);</span><br><span class="line">               &#125; else &#123;</span><br><span class="line">                   currentRegistryProcessors.add(ppName);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">	</span><br><span class="line">	// 重排序实现接口 PriorityOrdered 的 beanFactoryPostProcessors，遍历并调用执行</span><br><span class="line">       sortPostProcessors(regularPostProcessors, beanFactory);</span><br><span class="line">       invokeBeanFactoryPostProcessors((Collection)regularPostProcessors, (ConfigurableListableBeanFactory)beanFactory);</span><br><span class="line">       List&lt;BeanFactoryPostProcessor&gt; orderedPostProcessors = new ArrayList();</span><br><span class="line">       Iterator var21 = registryProcessors.iterator();</span><br><span class="line"></span><br><span class="line">       while(var21.hasNext()) &#123;</span><br><span class="line">           String postProcessorName = (String)var21.next();</span><br><span class="line">           orderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">	// 重排序实现接口 Ordered 的 beanFactoryPostProcessors，遍历并调用执行</span><br><span class="line">       sortPostProcessors(orderedPostProcessors, beanFactory);</span><br><span class="line">       invokeBeanFactoryPostProcessors((Collection)orderedPostProcessors, (ConfigurableListableBeanFactory)beanFactory);</span><br><span class="line">       List&lt;BeanFactoryPostProcessor&gt; nonOrderedPostProcessors = new ArrayList();</span><br><span class="line">       Iterator var24 = currentRegistryProcessors.iterator();</span><br><span class="line"></span><br><span class="line">       while(var24.hasNext()) &#123;</span><br><span class="line">           ppName = (String)var24.next();</span><br><span class="line">           nonOrderedPostProcessors.add(beanFactory.getBean(ppName, BeanFactoryPostProcessor.class));</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">	// 遍历调用其余没有实现排序接口的 beanFactoryPostProcessor</span><br><span class="line">       invokeBeanFactoryPostProcessors((Collection)nonOrderedPostProcessors, (ConfigurableListableBeanFactory)beanFactory);</span><br><span class="line">       </span><br><span class="line">       // 清空缓存</span><br><span class="line">       beanFactory.clearMetadataCache();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h3 id="registerBeanPostProcessors"><a href="#registerBeanPostProcessors" class="headerlink" title="registerBeanPostProcessors()"></a>registerBeanPostProcessors()</h3><p>registerBeanPostProcessors() 主要是找到容器中的 BeanPostProcessor 类型的 bean，根据具体的实现 PriorityOrdered，Ordered, 进行分类并排序，然后注册到 beanFactory 中的属性列表中，具体的实现被 AbstractApplicationContext 交由 PostProcessorRegistrationDelegate.registerBeanPostProcessors 实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">// PostProcessorRegistrationDelegate.class</span><br><span class="line">public static void registerBeanPostProcessors(ConfigurableListableBeanFactory beanFactory, AbstractApplicationContext applicationContext) &#123;</span><br><span class="line"></span><br><span class="line">		// 获取所有类型为 BeanPostProcessor 的 postProcessorNames</span><br><span class="line">        String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanPostProcessor.class, true, false);</span><br><span class="line">        // 统计总数</span><br><span class="line">        int beanProcessorTargetCount = beanFactory.getBeanPostProcessorCount() + 1 + postProcessorNames.length;</span><br><span class="line">        </span><br><span class="line">        // 在 beanFactory 中添加 PostProcessorRegistrationDelegate 委托类的子类 BeanPostProcessorChecker 检查类，用于在 beanPostProcessor 实例化期间，当 bean 被创建时打印信息</span><br><span class="line">        beanFactory.addBeanPostProcessor(new PostProcessorRegistrationDelegate.BeanPostProcessorChecker(beanFactory, beanProcessorTargetCount));</span><br><span class="line">        </span><br><span class="line">        // 构建列表 priorityOrderedPostProcessors, internalPostProcessors, </span><br><span class="line">        	orderedPostProcessorNames, nonOrderedPostProcessorNames，用于存储不同类型的 postProcessor</span><br><span class="line">        List&lt;BeanPostProcessor&gt; priorityOrderedPostProcessors = new ArrayList();</span><br><span class="line">        List&lt;BeanPostProcessor&gt; internalPostProcessors = new ArrayList();</span><br><span class="line">        List&lt;String&gt; orderedPostProcessorNames = new ArrayList();</span><br><span class="line">        List&lt;String&gt; nonOrderedPostProcessorNames = new ArrayList();</span><br><span class="line">        String[] var8 = postProcessorNames;</span><br><span class="line">        int var9 = postProcessorNames.length;</span><br><span class="line"></span><br><span class="line">		// 遍历 beanPostProcessor name array，根据 beanPostProcessor 的具体类型进行分类</span><br><span class="line">        String ppName;</span><br><span class="line">        BeanPostProcessor pp;</span><br><span class="line">        for(int var10 = 0; var10 &lt; var9; ++var10) &#123;</span><br><span class="line">            ppName = var8[var10];</span><br><span class="line">            if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123;</span><br><span class="line">                pp = (BeanPostProcessor)beanFactory.getBean(ppName, BeanPostProcessor.class);</span><br><span class="line">                priorityOrderedPostProcessors.add(pp);</span><br><span class="line">                if (pp instanceof MergedBeanDefinitionPostProcessor) &#123;</span><br><span class="line">                    internalPostProcessors.add(pp);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else if (beanFactory.isTypeMatch(ppName, Ordered.class)) &#123;</span><br><span class="line">                orderedPostProcessorNames.add(ppName);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                nonOrderedPostProcessorNames.add(ppName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">		// 加载实现 PriorityOrdered 接口的 beanPostProcessors，根据优先级进行排序，然后对 priorityOrderedPostProcessors 进行遍历注册到 beanFactory</span><br><span class="line">        sortPostProcessors(priorityOrderedPostProcessors, beanFactory);</span><br><span class="line">        registerBeanPostProcessors(beanFactory, (List)priorityOrderedPostProcessors);</span><br><span class="line">        </span><br><span class="line">        // 加载实现 Ordered 接口的 beanPostProcessors，排序后遍历注册到 beanFactory 中</span><br><span class="line">        List&lt;BeanPostProcessor&gt; orderedPostProcessors = new ArrayList();</span><br><span class="line">        Iterator var14 = orderedPostProcessorNames.iterator();</span><br><span class="line"></span><br><span class="line">        while(var14.hasNext()) &#123;</span><br><span class="line">            String ppName = (String)var14.next();</span><br><span class="line">            BeanPostProcessor pp = (BeanPostProcessor)beanFactory.getBean(ppName, BeanPostProcessor.class);</span><br><span class="line">            orderedPostProcessors.add(pp);</span><br><span class="line">            if (pp instanceof MergedBeanDefinitionPostProcessor) &#123;</span><br><span class="line">                internalPostProcessors.add(pp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sortPostProcessors(orderedPostProcessors, beanFactory);</span><br><span class="line">        registerBeanPostProcessors(beanFactory, (List)orderedPostProcessors);</span><br><span class="line">        </span><br><span class="line">        // 加载剩余未实现 ordered 的 beanPostProcessors, 遍历并加载到 beanFactory 中</span><br><span class="line">        List&lt;BeanPostProcessor&gt; nonOrderedPostProcessors = new ArrayList();</span><br><span class="line">        Iterator var17 = nonOrderedPostProcessorNames.iterator();</span><br><span class="line"></span><br><span class="line">        while(var17.hasNext()) &#123;</span><br><span class="line">            ppName = (String)var17.next();</span><br><span class="line">            pp = (BeanPostProcessor)beanFactory.getBean(ppName, BeanPostProcessor.class);</span><br><span class="line">            nonOrderedPostProcessors.add(pp);</span><br><span class="line">            if (pp instanceof MergedBeanDefinitionPostProcessor) &#123;</span><br><span class="line">                internalPostProcessors.add(pp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        registerBeanPostProcessors(beanFactory, (List)nonOrderedPostProcessors);</span><br><span class="line">        sortPostProcessors(internalPostProcessors, beanFactory);</span><br><span class="line">        </span><br><span class="line">        // 遍历注册内部后置处理器 internalPostProcessors，</span><br><span class="line">        registerBeanPostProcessors(beanFactory, (List)internalPostProcessors);</span><br><span class="line">        </span><br><span class="line">        // 重新注册 用于检查内部bean 的 postProcessor （ApplicationListenerDetector），</span><br><span class="line">        // 将这个检查处理器重新移动到 processors chain 末尾</span><br><span class="line">        beanFactory.addBeanPostProcessor(new ApplicationListenerDetector(applicationContext));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h3 id="initMessageSource"><a href="#initMessageSource" class="headerlink" title="initMessageSource()"></a>initMessageSource()</h3><p>MessageSource 是 Spring 支持国际化的一种方式，通过 MessageSource，可以读取根据 Locale 的具体位置设置，自动选择对应的 messages.properties (messages_en.properties, messages_ch_properties) 配置文件。然后根据业务需求 getMessage() 的到我们要的配置信息。  </p>
<p>而 initMessageSource() 的作用就在于读取 messageSource bean，并进行初始化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">protected void initMessageSource() &#123;</span><br><span class="line">        ConfigurableListableBeanFactory beanFactory = this.getBeanFactory();</span><br><span class="line">        </span><br><span class="line">        // 判断本地是否存在 messageSource bean</span><br><span class="line">        if (beanFactory.containsLocalBean(&quot;messageSource&quot;)) &#123;</span><br><span class="line">            this.messageSource = (MessageSource)beanFactory.getBean(&quot;messageSource&quot;, MessageSource.class);</span><br><span class="line">            </span><br><span class="line">            // 如果属于 HierarchicalMessageSource (可用于处理分层 messageSource)，那么设置父属性</span><br><span class="line">            if (this.parent != null &amp;&amp; this.messageSource instanceof HierarchicalMessageSource) &#123;</span><br><span class="line">                HierarchicalMessageSource hms = (HierarchicalMessageSource)this.messageSource;</span><br><span class="line">                if (hms.getParentMessageSource() == null) &#123;</span><br><span class="line">                    hms.setParentMessageSource(this.getInternalParentMessageSource());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">        </span><br><span class="line">        	// 否则创建一个新的对象</span><br><span class="line">            DelegatingMessageSource dms = new DelegatingMessageSource();</span><br><span class="line">            </span><br><span class="line">            // 然后属性设置</span><br><span class="line">            dms.setParentMessageSource(this.getInternalParentMessageSource());</span><br><span class="line">            this.messageSource = dms;</span><br><span class="line">            </span><br><span class="line">            // 最后，将 messageSource 作为一个单例的 bean 注册到 beanFactory 中</span><br><span class="line">            beanFactory.registerSingleton(&quot;messageSource&quot;, this.messageSource);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h3 id="initApplicationEventMulticaster"><a href="#initApplicationEventMulticaster" class="headerlink" title="initApplicationEventMulticaster()"></a>initApplicationEventMulticaster()</h3><p>通常，我们在 Spring 中 发送一个事件 event 是采用 applicationContext.pushEvent() ，实际上，具体的事件发送广播是被交由 applicationEventMulticaster 发送，具体的过程将后续将会出一篇 Spring Event 事件机制进行介绍。而 initApplicationEventMulticaster() 就是将 applicationEventMulticater 注册到 beanFactory 容器中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// AbstractApplicationContext.class</span><br><span class="line">protected void initApplicationEventMulticaster() &#123;</span><br><span class="line">		</span><br><span class="line">		// 获取 beanFactory，判断本地是否存在 bean 组件 applicationEventMulticaster</span><br><span class="line">        ConfigurableListableBeanFactory beanFactory = this.getBeanFactory();</span><br><span class="line">        if (beanFactory.containsLocalBean(&quot;applicationEventMulticaster&quot;)) &#123;</span><br><span class="line">            this.applicationEventMulticaster = (ApplicationEventMulticaster)beanFactory.getBean(&quot;applicationEventMulticaster&quot;, ApplicationEventMulticaster.class);</span><br><span class="line">           ...</span><br><span class="line"></span><br><span class="line">        &#125; else &#123;</span><br><span class="line">        </span><br><span class="line">        	// 如果本地不存在，则实例化一个 simpleApplicationEventMulticaster，并且单例注册到 beanfactory </span><br><span class="line">            this.applicationEventMulticaster = new SimpleApplicationEventMulticaster(beanFactory);</span><br><span class="line">            beanFactory.registerSingleton(&quot;applicationEventMulticaster&quot;, this.applicationEventMulticaster);</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h3 id="onRefresh"><a href="#onRefresh" class="headerlink" title="onRefresh()"></a>onRefresh()</h3><p>onRefresh() 和上面的 postProcessBeanFactory() 一样，都是一个模板方法，具体的实现会根据 webApplicationType 的具体类型找到对应的 GenericWebApplicationContext || ReactiveWebServerApplicationContext 等，具体实现都有所不同。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// AbstractApplicationContext.class</span><br><span class="line">protected void onRefresh() throws BeansException &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// GenericWebApplicationContext.class</span><br><span class="line">// 具体过程是初始化主题</span><br><span class="line">protected void onRefresh() &#123;</span><br><span class="line">        this.themeSource = UiApplicationContextUtils.initThemeSource(this);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// ServletWebServerApplicationContext.class // ReactiveWebServerApplicationContext</span><br><span class="line">// 具体过程是构建一个 servlet webServer</span><br><span class="line">protected void onRefresh() &#123;</span><br><span class="line">        super.onRefresh();</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            this.createWebServer();</span><br><span class="line">        &#125; catch (Throwable var2) &#123;</span><br><span class="line">            throw new ApplicationContextException(&quot;Unable to start web server&quot;, var2);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h3 id="registerListeners"><a href="#registerListeners" class="headerlink" title="registerListeners()"></a>registerListeners()</h3><p>在上面的步骤中，我们已经将事件广播器 applicationEventMulticaster 注册到了容器中，有了广播器，那么接下来就是收集容器中的所有 listener bean 组件，将他们保存在集合中，以便事件发布时能够遍历监听器列表，通过适配 eventType，找到对应的 listener 并进行处理。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">// AbstractApplicationContext.class</span><br><span class="line">protected void registerListeners() &#123;</span><br><span class="line">		// 获取监听器 listeners 集合，这里的 listeners 是各个模块中的 spirng.factories 中的 listeners</span><br><span class="line">        Iterator var1 = this.getApplicationListeners().iterator();</span><br><span class="line"></span><br><span class="line">		// 遍历listeners ，加入到 AbstractApplicationEventListeners中的 applicationListeners 集合中</span><br><span class="line">        while(var1.hasNext()) &#123;</span><br><span class="line">            ApplicationListener&lt;?&gt; listener = (ApplicationListener)var1.next();</span><br><span class="line">            this.getApplicationEventMulticaster().addApplicationListener(listener);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">		// 获取所有监听器的名称，并遍历加入到 AbstractApplicationEventListeners applicationListenerBeans 		// 这里的 listeners 指的是容器中实现了 ApplicationListener 的 bean 组件</span><br><span class="line">		// 包括了我们自定义的 listener 或者是 spring中定义的 @Bean mvcResourceUrlProvider</span><br><span class="line">        String[] listenerBeanNames = this.getBeanNamesForType(ApplicationListener.class, true, false);</span><br><span class="line">        String[] var7 = listenerBeanNames;</span><br><span class="line">        int var3 = listenerBeanNames.length;</span><br><span class="line"></span><br><span class="line">        for(int var4 = 0; var4 &lt; var3; ++var4) &#123;</span><br><span class="line">            String listenerBeanName = var7[var4];</span><br><span class="line">            this.getApplicationEventMulticaster().addApplicationListenerBean(listenerBeanName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">		// 如果存在早期事件，那么直接发布出去</span><br><span class="line">        Set&lt;ApplicationEvent&gt; earlyEventsToProcess = this.earlyApplicationEvents;</span><br><span class="line">        this.earlyApplicationEvents = null;</span><br><span class="line">        if (earlyEventsToProcess != null) &#123;</span><br><span class="line">            Iterator var9 = earlyEventsToProcess.iterator();</span><br><span class="line"></span><br><span class="line">            while(var9.hasNext()) &#123;</span><br><span class="line">                ApplicationEvent earlyEvent = (ApplicationEvent)var9.next();</span><br><span class="line">                this.getApplicationEventMulticaster().multicastEvent(earlyEvent);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h3 id="finishBeanFactoryInitialization"><a href="#finishBeanFactoryInitialization" class="headerlink" title="finishBeanFactoryInitialization()"></a>finishBeanFactoryInitialization()</h3><p>finishBeanFactoryInitialization(beanFactory) 的主要作用是实例化所有的单例 bean ( 非 Lazy )，这个时候，容器中的 beanPostProcessor 将会开始起作用。 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">protected void finishBeanFactoryInitialization(ConfigurableListableBeanFactory beanFactory) &#123;</span><br><span class="line">		// 初始化 context 的转换服务, conversionService 是一个类型转换接口，可实现自定义类型间的转换</span><br><span class="line">        if (beanFactory.containsBean(&quot;conversionService&quot;) &amp;&amp; beanFactory.isTypeMatch(&quot;conversionService&quot;, ConversionService.class)) &#123;</span><br><span class="line">            beanFactory.setConversionService((ConversionService)beanFactory.getBean(&quot;conversionService&quot;, ConversionService.class));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">		// 注册内置的值处理器，用于对 property 进行处理（例如占位符处理）</span><br><span class="line">        if (!beanFactory.hasEmbeddedValueResolver()) &#123;</span><br><span class="line">            beanFactory.addEmbeddedValueResolver((strVal) -&gt; &#123;</span><br><span class="line">                return this.getEnvironment().resolvePlaceholders(strVal);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">		// 获取 LoadTimeWeaverAware Bean</span><br><span class="line">        String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware.class, false, false);</span><br><span class="line">        String[] var3 = weaverAwareNames;</span><br><span class="line">        int var4 = weaverAwareNames.length;</span><br><span class="line"></span><br><span class="line">        for(int var5 = 0; var5 &lt; var4; ++var5) &#123;</span><br><span class="line">            String weaverAwareName = var3[var5];</span><br><span class="line">            this.getBean(weaverAwareName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">		// 停止使用临时的类加载器</span><br><span class="line">        beanFactory.setTempClassLoader((ClassLoader)null);</span><br><span class="line">        </span><br><span class="line">        // 缓存所有的 beanDefinition 数据，防止更改，实际上是将 beanDefinitionNames 进行备份</span><br><span class="line">        //  this.frozenBeanDefinitionNames = StringUtils.toStringArray(this.beanDefinitionNames)</span><br><span class="line">        beanFactory.freezeConfiguration();</span><br><span class="line">        </span><br><span class="line">        // 实例化所有的单例的bean (非 Lazy) </span><br><span class="line">        beanFactory.preInstantiateSingletons();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h3 id="finishRefresh"><a href="#finishRefresh" class="headerlink" title="finishRefresh()"></a>finishRefresh()</h3><p>finishRefresh() 的作用是做 refesh() 后的额外操作，例如清除上下文缓存 ( ASM 数据 )，初始化 生命周期处理器 LifeCycleProcessor，发布 上下文已经刷新事件 ContextRefreshedEvent.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">AbstractApplicationContext.class</span><br><span class="line">protected void finishRefresh() &#123;</span><br><span class="line">		// 清除 context level 的资源缓存，例如扫描中的 ASM 数据</span><br><span class="line">        this.clearResourceCaches();</span><br><span class="line">        </span><br><span class="line">        // 初始化 LifeCycleProcessor，和 initApplicationEventMulticaster 差不多，先检查本地，否者创建注册</span><br><span class="line">        this.initLifecycleProcessor();</span><br><span class="line">        </span><br><span class="line">        // 调用所有 LifeCycleBean 的 start()</span><br><span class="line">        this.getLifecycleProcessor().onRefresh();</span><br><span class="line">        </span><br><span class="line">        // 完成上下文刷新后，发布 ContextRefeshedEvent 上下文刷新事件</span><br><span class="line">        this.publishEvent((ApplicationEvent)(new ContextRefreshedEvent(this)));</span><br><span class="line">        </span><br><span class="line">        // 如果设置了 JMX 属性，那么将进行注册</span><br><span class="line">        LiveBeansView.registerApplicationContext(this);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>可以看出，refresh() 在 SpringBoot 的启动过程中，扮演着非常重要的角色，包括了注册重要的 bean 组件，实例化容器中的 bean，processors 之间的调用等，通过分析后，我们可以了解到了我们日常工作中使用到的各种实现例如 InstantiationAwareBeanPostProcessor ，Listener, LifeCycleProcessor 等组件的调用顺序及功能。</p>
<p>同时，refresh() 过程也很好的展示了 bean 的生命周期中各个组件的位置及作用，也对于我们理解 Spring 容器有了更好的理解。</p>
<p><img src="/images/springboot/bean-life-cycle.png" alt></p>
<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><ul>
<li><a href="https://juejin.im/post/5cc25d6ef265da036d79c11a" target="_blank" rel="noopener">聊聊国际化MessageSource</a></li>
<li><a href="https://blog.csdn.net/f641385712/article/details/88041409" target="_blank" rel="noopener">Spring IOC容器启动流程</a></li>
<li><a href="http://fangjian0423.github.io/2017/05/10/springboot-context-refresh/" target="_blank" rel="noopener">SpringBoot源码分析之Spring容器的refresh过程</a></li>
</ul>


      

    </section>
    
      <section class='ArticleMeta'>
          <div>
            发布于&nbsp;
            <time datetime="2019-10-30T06:44:20.000Z" itemprop="datePublished">
              2019-10-30
            </time>
          </div>
          
            <div>
              tags: 
  <li class="meta-text">
  { <a href="/tags/Spring/">Spring</a> }
  </li>

  <li class="meta-text">
  { <a href="/tags/SpringBoot/">SpringBoot</a> }
  </li>


            </div>
          
      </section>
    
    
</article>

  
</div>

            <footer>
    <div>© 2016 - John Doe </div>
    <div>
    Powered by Hexo
    </div>
</footer>

        </div>
    </div>
</div>
<script src="/js/pager/dist/singlepager.js"></script>
<script>
var sp = new Pager('data-pager-shell')

</script><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</body>
</html>